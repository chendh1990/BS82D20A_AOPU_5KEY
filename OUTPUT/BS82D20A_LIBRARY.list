				;file F:\SVNRepo\Project\BS82D20A_AOPU_5KEY\MAIN_PROGRAM_V103\MAIN_PROGRAM_V103.asm
				;1	
				;2	message '****************************************************************'
				;3	message '*PROJECT NAME :MAIN PROGRAM V103                               *'
				;4	message '*     VERSION :V103                                            *'
				;5	message '* ICE VERSION :                                                *'
				;6	message '*      DATE   :20160302                                        *'
				;7	message '*      REMARK :V103 add 33~36 key                              *'
				;8	message '****************************************************************'
				;9	                ;=INCLUDE REFERENCE FILE
				;10	                INCLUDE MAIN_PROGRAM_V103.INC
				;11	
				;12	                ;-PUBLIC LABEL
				;13	                PUBLIC  _LOAD_TKS_GLOBE_VARIES
				;14	                PUBLIC  _LOAD_HXT_REFERENCE
				;15	
				;16	CALL_   MACRO   FUNCTION
				;17	        ifdef   FUNCTION
				;18	                ifdef   PBP
				;19	                MOV     A,bank FUNCTION
				;20	                MOV     PBP,A
				;21	                endif
				;22	                CALL    FUNCTION
				;23	        endif
				;24	                ENDM
				;25	
				;26	EXTEND_FUNCTION_INITIAL MACRO
				;27	                CALL_   EXTEND_FUNCTION_1A_INITIAL
				;28	                CALL_   EXTEND_FUNCTION_1B_INITIAL
				;29	                CALL_   EXTEND_FUNCTION_1C_INITIAL
				;30	                CALL_   EXTEND_FUNCTION_1D_INITIAL
				;31	                CALL_   EXTEND_FUNCTION_1E_INITIAL
				;32	                CALL_   EXTEND_FUNCTION_1F_INITIAL
				;33	                CALL_   EXTEND_FUNCTION_1G_INITIAL
				;34	                CALL_   EXTEND_FUNCTION_1H_INITIAL
				;35	
				;36	                CALL_   EXTEND_FUNCTION_2A_INITIAL
				;37	                CALL_   EXTEND_FUNCTION_2B_INITIAL
				;38	                CALL_   EXTEND_FUNCTION_2C_INITIAL
				;39	                CALL_   EXTEND_FUNCTION_2D_INITIAL
				;40	                CALL_   EXTEND_FUNCTION_2E_INITIAL
				;41	                CALL_   EXTEND_FUNCTION_2F_INITIAL
				;42	                CALL_   EXTEND_FUNCTION_2G_INITIAL
				;43	                CALL_   EXTEND_FUNCTION_2H_INITIAL
				;44	                ENDM
				;45	
				;46	EXTEND_FUNCTION MACRO
				;47	                CALL_   EXTEND_FUNCTION_1A
				;48	                CALL_   EXTEND_FUNCTION_1B
				;49	                CALL_   EXTEND_FUNCTION_1C
				;50	                CALL_   EXTEND_FUNCTION_1D
				;51	                CALL_   EXTEND_FUNCTION_1E
				;52	                CALL_   EXTEND_FUNCTION_1F
				;53	                CALL_   EXTEND_FUNCTION_1G
				;54	                CALL_   EXTEND_FUNCTION_1H
				;55	
				;56	                CALL_   EXTEND_FUNCTION_2A
				;57	                CALL_   EXTEND_FUNCTION_2B
				;58	                CALL_   EXTEND_FUNCTION_2C
				;59	                CALL_   EXTEND_FUNCTION_2D
				;60	                CALL_   EXTEND_FUNCTION_2E
				;61	                CALL_   EXTEND_FUNCTION_2F
				;62	                CALL_   EXTEND_FUNCTION_2G
				;63	                CALL_   EXTEND_FUNCTION_2H
				;64	                ENDM
				;65	                ;==============
				;66	                ;=DATA SETCTION
				;67	                ;==============
				;68	MAIN_DATA       .SECTION          'DATA'
				;69	
				;70	ifndef  ESCpowerIDcheck
				;71	POR_ID          DB      2 DUP(?)
				;72	endif
				;73	
				;74	
				;75	
				;76	                ;==============
				;77	                ;=CODE SETCTION
				;78	                ;==============
				;79	PROGRAM_ENTRY   .SECTION  AT 000H 'CODE'
				;80	        ifdef   PBP
				;81	                CLR     PBP
				;82	                ifndef  ESCpowerIDcheck
				;83	                MOV     A,042H      ;ASCII = B
				;84	                endif
				;85	        else
				;86	                ;----------------
				;87	                ;-SET POR ID 1---
				;88	                ;----------------
				;89	                ifndef  ESCpowerIDcheck
				;90	                MOV     A,042H      ;ASCII = B
				PROGRAM_ENTRY:
				include BS82D20A-3.inc
0000	0F42	mov     a, 42H
				;91	                SNZ     TO
0001	3A8A	snz     TO
				;92	                MOV     POR_ID[0],A
0002	40B5	mov     POR_ID, a
				;93	                endif
				;94	        endif
				;95	                JMP     PROGRAM_RESET
0003	2D21	jmp     PROGRAM_RESET
				;96	
				;97	                ;==============
				;98	                ;=MAIN PROGRAM=
				;99	                ;==============
				;100	MAIN_PROGRAM    .SECTION          'CODE'
				;101	
				;102	                ;;***********************
				;103	PROGRAM_RESET:  ;;* PROGRAM ENTRY *******
				;104	                ;;***********************
				;105	        ifdef   PBP
				;106	                ifndef  ESCpowerIDcheck
				;107	                SNZ     TO
				;108	                MOV     POR_ID[0],A
				;109	                endif
				;110	        endif
				;111	                ;----------------
				;112	                ;-SET POR ID 2---
				;113	                ;----------------
				;114	        ifndef  ESCpowerIDcheck
				;115	                MOV     A,053H      ;ASCII = S
				PROGRAM_RESET:
				MAIN_PROGRAM:
0521	0F53	mov     a, 53H
				;116	                MOV     POR_ID[1],A
0522	40B6	mov     POR_ID[1], a
				;117	        endif
				;118	
				;119	
				;120	                ;---------------------
				;121	                ;-MCU HARDWARE INITIAL
				;122	                ;---------------------
				;123	                MCU_HARDWARE_INITIAL
0523	0F00	mov     a, 0H
0524	00BD	mov     CTRL, a
0525	0F03	mov     a, 3H
0526	008B	mov     SMOD, a
0527	0F52	mov     a, 52H
0528	009A	mov     WDTC, a
0529	0F05	mov     a, 5H
052A	0084	mov     BP, a
052B	0F80	mov     a, 80H
052C	2558	call    CLEAR_RAM
052D	0F04	mov     a, 4H
052E	0084	mov     BP, a
052F	0F80	mov     a, 80H
0530	2558	call    CLEAR_RAM
0531	0F03	mov     a, 3H
0532	0084	mov     BP, a
0533	0F80	mov     a, 80H
0534	2558	call    CLEAR_RAM
0535	0F02	mov     a, 2H
0536	0084	mov     BP, a
0537	0F80	mov     a, 80H
0538	2558	call    CLEAR_RAM
0539	0F01	mov     a, 1H
053A	0084	mov     BP, a
053B	0F80	mov     a, 80H
053C	2558	call    CLEAR_RAM
053D	1F04	clr     BP
053E	0F80	mov     a, 80H
053F	2558	call    CLEAR_RAM
				;124	
				;125	                ;------------------------------
				;126	                ;-LOAD LIBRARY OPTION/THRESHOLD
				;127	                ;------------------------------
				;128	                CALL    _LOAD_TKS_GLOBE_VARIES
0540	2565	call    _LOAD_HXT_REFERENCE
				;129	
				;130	                ;------------------------
				;131	                ;-EXTEND FUNCTION INITIAL
				;132	                ;------------------------
				;133	                EXTEND_FUNCTION_INITIAL
0541	20D3	call    L00D3
0542	263A	call    _USER_PROGRAM_INITIAL
				;134	
				;135	                ;;-----------------------
				;136	MAIN_LOOP:      ;;- MAIN PROGRAM LOOP ---
				;137	                ;;-----------------------
				;138	                CLR     WDT
				MAIN_LOOP:
0543	0001	clr     wdt
				;139	                CLR     WDT1
0544	0001	clr     wdt
				;140	                CLR     WDT2
0545	0005	clr     wdt2
				;141	
				;142	                ;----------------
				;143	                ;-CHECK POR ID --
				;144	                ;----------------
				;145	        ifndef  ESCpowerIDcheck
				;146	                MOV     A,042H
0546	0F42	mov     a, 42H
				;147	                XORM    A,POR_ID[0]
0547	44B5	xorm    a, POR_ID
				;148	                MOV     A,053H
0548	0F53	mov     a, 53H
				;149	                SZ      Z
0549	3D0A	sz      Z
				;150	                XORM    A,POR_ID[1]
054A	44B6	xorm    a, POR_ID[1]
				;151	                SNZ     Z
054B	390A	snz     Z
				;152	                JMP     000H
054C	2800	jmp     PROGRAM_ENTRY
				;153	        endif
				;154	                ;----------------------
				;155	                ;-RE INITIAL SYS. CLOCK
				;156	                ;----------------------
				;157	                RELOAD_SYS_CLOCK
054D	0F00	mov     a, 0H
054E	00BD	mov     CTRL, a
054F	0F03	mov     a, 3H
0550	008B	mov     SMOD, a
				;158	                EXTEND_FUNCTION
0551	201C	call    L001C
0552	2649	call    _USER_PROGRAM
				;159	                ;----------------
				;160	                ;-SET POR ID  ---
				;161	                ;----------------
				;162	        ifndef  ESCpowerIDcheck
				;163	                MOV     A,042H      ;ASCII = B
0553	0F42	mov     a, 42H
				;164	                MOV     POR_ID[0],A
0554	40B5	mov     POR_ID, a
				;165	                MOV     A,053H      ;ASCII = S
0555	0F53	mov     a, 53H
				;166	                MOV     POR_ID[1],A
0556	40B6	mov     POR_ID[1], a
				;167	        endif
				;168	
				;169	                ;--------------------
				;170	WDT_WAKEUP:     ;-WDT WAKEUP FUNCTION
				;171	                ;--------------------
				;172	                if      PowerSave==1
				;173	                CALL_   _CHECK_KEY_WAKEUP
				;174	                endif
				;175	
				;176	                ifdef   PBP
				;177	                MOV     A,BANK MAIN_LOOP
				;178	                MOV     PBP,A
				;179	                endif
				;180	                JMP     MAIN_LOOP
				WDT_WAKEUP:
0557	2D43	jmp     MAIN_LOOP
				;181	
				;182	
				;183	
				;184	
				;185	
				;186	
				;187	
				;188	
				;189	
				;190	;;***********************************************************
				;191	;;*SUB. NAME:                                               *
				;192	;;*INPUT    :                                               *
				;193	;;*OUTPUT   :                                               *
				;194	;;*USED REG.:                                               *
				;195	;;*FUNCTION :                                               *
				;196	;;***********************************************************
				;197	CLEAR_RAM:
				;198	                MOV     MP1,A
				CLEAR_RAM:
0558	0083	mov     MP1, a
				;199	        ifndef  ESCpowerIDcheck
				;200	            ifdef  BP
				;201	                ;-CHECK BANK
				;202	                SZ      BP
0559	1084	sz      BP
				;203	                JMP     CLR_RAM
055A	2D61	jmp     CLR_RAM
				;204	            endif
				;205	                ;-CHECK POR_ID RAM
				;206	                MOV     A,OFFSET POR_ID
055B	0FB5	mov     a, B5H
				;207	                XOR     A,MP1
055C	0403	xor     a, MP1
				;208	                MOV     A,OFFSET POR_ID+1
055D	0FB6	mov     a, B6H
				;209	                SNZ     Z
055E	390A	snz     Z
				;210	                XOR     A,MP1
055F	0403	xor     a, MP1
				;211	                SNZ     Z
0560	390A	snz     Z
				;212	        endif
				;213	CLR_RAM:        ;-CLEAR RAM
				;214	                CLR     IAR1
				CLR_RAM:
0561	1F02	clr     [02H]
				;215	                SIZA    MP1
0562	1603	siza    MP1
				;216	                JMP     CLEAR_RAM
0563	2D58	jmp     CLEAR_RAM
				;217	
				;218	                RET
0564	0003	ret
				;219	
				;220	
				;221	;;***********************************************************
				;222	;;*SUB. NAME:                                               *
				;223	;;*INPUT    :                                               *
				;224	;;*OUTPUT   :                                               *
				;225	;;*USED REG.:                                               *
				;226	;;*FUNCTION :                                               *
				;227	;;***********************************************************
				;228	_LOAD_TKS_GLOBE_VARIES:
				;229	_LOAD_HXT_REFERENCE:
				;230	                ;------------------------
				;231	                ;-SET TKS LIBRARY OPTION-
				;232	                ;------------------------
				;233	                MOV     A,GlobeOptionA
				_LOAD_HXT_REFERENCE:
				_LOAD_TKS_GLOBE_VARIES:
0565	0F70	mov     a, 70H
				;234	                MOV     _GLOBE_VARIES[0],A
0566	4080	mov     __ptm0ah[20], a
				;235	                MOV     A,GlobeOptionB
0567	0FF0	mov     a, F0H
				;236	                MOV     _GLOBE_VARIES[1],A
0568	4081	mov     __ptm0ah[21], a
				;237	                MOV     A,GlobeOptionC
0569	0F88	mov     a, 88H
				;238	                MOV     _GLOBE_VARIES[2],A
056A	4082	mov     __ptm0ah[22], a
				;239	
				;240	                ;--------------------------
				;241	                ;-SET TOUCH OR IO ATTRIBUTE
				;242	                ;--------------------------
				;243	                MOV     A,IO_TOUCH_ATTR&0FFH
056B	0F0F	mov     a, FH
				;244	                MOV     _KEY_IO_SEL[0],A
056C	40A2	mov     __ptm0ah[54], a
				;245	                ;-IF OVER 2 TOUCH IP (8~16KEY)
				;246	                if      TouchKeyAmount > 8
				;247	                MOV     A,(IO_TOUCH_ATTR>>8)&0FFH
056D	0F00	mov     a, 0H
				;248	                MOV     _KEY_IO_SEL[1],A
056E	40A3	mov     __ptm0ah[55], a
				;249	                endif
				;250	                ;-IF OVER 4 TOUCH IP (17~24KEY)
				;251	                if      TouchKeyAmount > 16
				;252	                MOV     A,(IO_TOUCH_ATTR>>16)&0FFH
056F	0F04	mov     a, 4H
				;253	                MOV     _KEY_IO_SEL[2],A
0570	40A4	mov     __ptm0ah[56], a
				;254	                endif
				;255	                ;-IF OVER 6 TOUCH IP (25~32KEY)
				;256	                if      TouchKeyAmount > 24
				;257	                MOV     A,(IO_TOUCH_ATTR>>24)&0FFH
				;258	                MOV     _KEY_IO_SEL[3],A
				;259	                endif
				;260	
				;261	                ;-IF OVER 6 TOUCH IP (33~36KEY)
				;262	                if      TouchKeyAmount > 32
				;263	                MOV     A,IO_TOUCH_ATTR2
				;264	                MOV     _KEY_IO_SEL[4],A
				;265	                endif
				;266	
				;267	                ;------------------------
				;268	                ;-SET TOUCH KEY THRESHOLD
				;269	                ;------------------------
				;270	                ;-KEY1 THRESHOLD
				;271	                MOV     A,Key1Threshold
0571	0F10	mov     a, 10H
				;272	                MOV     _GLOBE_VARIES[3],A
0572	4083	mov     __ptm0ah[23], a
				;273	
				;274	                if      TouchKeyAmount > 1
				;275	                ;-KEY2 THRESHOLD
				;276	                MOV     A,Key2Threshold
0573	0F10	mov     a, 10H
				;277	                MOV     _GLOBE_VARIES[4],A
0574	4084	mov     __ptm0ah[24], a
				;278	                endif
				;279	
				;280	                if      TouchKeyAmount > 2
				;281	                ;-KEY3 THRESHOLD
				;282	                MOV     A,Key3Threshold
0575	0F10	mov     a, 10H
				;283	                MOV     _GLOBE_VARIES[5],A
0576	4085	mov     __ptm0ah[25], a
				;284	                endif
				;285	
				;286	                if      TouchKeyAmount > 3
				;287	                ;-KEY4 THRESHOLD
				;288	                MOV     A,Key4Threshold
0577	0F10	mov     a, 10H
				;289	                MOV     _GLOBE_VARIES[6],A
0578	4086	mov     __ptm0ah[26], a
				;290	                endif
				;291	
				;292	                if      TouchKeyAmount > 4
				;293	                ;-KEY5 THRESHOLD
				;294	                MOV     A,Key5Threshold
0579	0F10	mov     a, 10H
				;295	                MOV     _GLOBE_VARIES[7],A
057A	4087	mov     __ptm0ah[27], a
				;296	                endif
				;297	
				;298	                if      TouchKeyAmount > 5
				;299	                ;-KEY6 THRESHOLD
				;300	                MOV     A,Key6Threshold
057B	0F10	mov     a, 10H
				;301	                MOV     _GLOBE_VARIES[8],A
057C	4088	mov     __ptm0ah[28], a
				;302	                endif
				;303	
				;304	                if      TouchKeyAmount > 6
				;305	                ;-KEY7 THRESHOLD
				;306	                MOV     A,Key7Threshold
057D	0F10	mov     a, 10H
				;307	                MOV     _GLOBE_VARIES[9],A
057E	4089	mov     __ptm0ah[29], a
				;308	                endif
				;309	
				;310	                if      TouchKeyAmount > 7
				;311	                ;-KEY8 THRESHOLD
				;312	                MOV     A,Key8Threshold
057F	0F10	mov     a, 10H
				;313	                MOV     _GLOBE_VARIES[10],A
0580	408A	mov     __ptm0ah[30], a
				;314	                endif
				;315	
				;316	                if     TouchKeyAmount > 8
				;317	                ;-KEY9 THRESHOLD
				;318	                MOV     A,Key9Threshold
0581	0F10	mov     a, 10H
				;319	                MOV     _GLOBE_VARIES[11],A
0582	408B	mov     __ptm0ah[31], a
				;320	                endif
				;321	
				;322	                if      TouchKeyAmount > 9
				;323	                ;-KEY10 THRESHOLD
				;324	                MOV     A,Key10Threshold
0583	0F10	mov     a, 10H
				;325	                MOV     _GLOBE_VARIES[12],A
0584	408C	mov     __ptm0ah[32], a
				;326	                endif
				;327	
				;328	                if      TouchKeyAmount > 10
				;329	                ;-KEY11 THRESHOLD
				;330	                MOV     A,Key11Threshold
0585	0F10	mov     a, 10H
				;331	                MOV     _GLOBE_VARIES[13],A
0586	408D	mov     __ptm0ah[33], a
				;332	                endif
				;333	
				;334	                if      TouchKeyAmount > 11
				;335	                ;-KEY12 THRESHOLD
				;336	                MOV     A,Key12Threshold
0587	0F10	mov     a, 10H
				;337	                MOV     _GLOBE_VARIES[14],A
0588	408E	mov     __ptm0ah[34], a
				;338	                endif
				;339	
				;340	                if      TouchKeyAmount > 12
				;341	                ;-KEY13 THRESHOLD
				;342	                MOV     A,Key13Threshold
0589	0F10	mov     a, 10H
				;343	                MOV     _GLOBE_VARIES[15],A
058A	408F	mov     __ptm0ah[35], a
				;344	                endif
				;345	
				;346	                if      TouchKeyAmount > 13
				;347	                ;-KEY14 THRESHOLD
				;348	                MOV     A,Key14Threshold
058B	0F10	mov     a, 10H
				;349	                MOV     _GLOBE_VARIES[16],A
058C	4090	mov     __ptm0ah[36], a
				;350	                endif
				;351	
				;352	                if      TouchKeyAmount > 14
				;353	                ;-KEY15 THRESHOLD
				;354	                MOV     A,Key15Threshold
058D	0F10	mov     a, 10H
				;355	                MOV     _GLOBE_VARIES[17],A
058E	4091	mov     __ptm0ah[37], a
				;356	                endif
				;357	
				;358	                if      TouchKeyAmount > 15
				;359	                ;-KEY16 THRESHOLD
				;360	                MOV     A,Key16Threshold
058F	0F10	mov     a, 10H
				;361	                MOV     _GLOBE_VARIES[18],A
0590	4092	mov     __ptm0ah[38], a
				;362	                endif
				;363	
				;364	                if      TouchKeyAmount > 16
				;365	                ;-KEY17 THRESHOLD
				;366	                MOV     A,Key17Threshold
0591	0F10	mov     a, 10H
				;367	                MOV     _GLOBE_VARIES[19],A
0592	4093	mov     __ptm0ah[39], a
				;368	                endif
				;369	
				;370	                if      TouchKeyAmount > 17
				;371	                ;-KEY18 THRESHOLD
				;372	                MOV     A,Key18Threshold
0593	0F10	mov     a, 10H
				;373	                MOV     _GLOBE_VARIES[20],A
0594	4094	mov     __ptm0ah[40], a
				;374	                endif
				;375	
				;376	                if      TouchKeyAmount > 18
				;377	                ;-KEY19 THRESHOLD
				;378	                MOV     A,Key19Threshold
0595	0F10	mov     a, 10H
				;379	                MOV     _GLOBE_VARIES[21],A
0596	4095	mov     __ptm0ah[41], a
				;380	                endif
				;381	
				;382	                if      TouchKeyAmount > 19
				;383	                ;-KEY20 THRESHOLD
				;384	                MOV     A,Key20Threshold
0597	0F10	mov     a, 10H
				;385	                MOV     _GLOBE_VARIES[22],A
0598	4096	mov     __ptm0ah[42], a
				;386	                endif
				;387	
				;388	                if      TouchKeyAmount > 20
				;389	                ;-KEY17 THRESHOLD
				;390	                MOV     A,Key21Threshold
				;391	                MOV     _GLOBE_VARIES[23],A
				;392	                endif
				;393	
				;394	                if      TouchKeyAmount > 21
				;395	                ;-KEY18 THRESHOLD
				;396	                MOV     A,Key22Threshold
				;397	                MOV     _GLOBE_VARIES[24],A
				;398	                endif
				;399	
				;400	                if      TouchKeyAmount > 22
				;401	                ;-KEY19 THRESHOLD
				;402	                MOV     A,Key23Threshold
				;403	                MOV     _GLOBE_VARIES[25],A
				;404	                endif
				;405	
				;406	                if      TouchKeyAmount > 23
				;407	                ;-KEY20 THRESHOLD
				;408	                MOV     A,Key24Threshold
				;409	                MOV     _GLOBE_VARIES[26],A
				;410	                endif
				;411	
				;412	                if      TouchKeyAmount > 24
				;413	                ;-KEY17 THRESHOLD
				;414	                MOV     A,Key25Threshold
				;415	                MOV     _GLOBE_VARIES[27],A
				;416	                endif
				;417	
				;418	                if      TouchKeyAmount > 25
				;419	                ;-KEY18 THRESHOLD
				;420	                MOV     A,Key26Threshold
				;421	                MOV     _GLOBE_VARIES[28],A
				;422	                endif
				;423	
				;424	                if      TouchKeyAmount > 26
				;425	                ;-KEY19 THRESHOLD
				;426	                MOV     A,Key27Threshold
				;427	                MOV     _GLOBE_VARIES[29],A
				;428	                endif
				;429	
				;430	                if      TouchKeyAmount > 27
				;431	                ;-KEY20 THRESHOLD
				;432	                MOV     A,Key28Threshold
				;433	                MOV     _GLOBE_VARIES[30],A
				;434	                endif
				;435	
				;436	                if      TouchKeyAmount > 28
				;437	                ;-KEY29 THRESHOLD
				;438	                MOV     A,Key29Threshold
				;439	                MOV     _GLOBE_VARIES[31],A
				;440	                endif
				;441	
				;442	                if      TouchKeyAmount > 29
				;443	                ;-KEY30 THRESHOLD
				;444	                MOV     A,Key30Threshold
				;445	                MOV     _GLOBE_VARIES[32],A
				;446	                endif
				;447	
				;448	                if      TouchKeyAmount > 30
				;449	                ;-KEY31 THRESHOLD
				;450	                MOV     A,Key31Threshold
				;451	                MOV     _GLOBE_VARIES[33],A
				;452	                endif
				;453	
				;454	                if      TouchKeyAmount > 31
				;455	                ;-KEY32 THRESHOLD
				;456	                MOV     A,Key32Threshold
				;457	                MOV     _GLOBE_VARIES[34],A
				;458	                endif
				;459	
				;460	                if      TouchKeyAmount > 32
				;461	                ;-KEY33 THRESHOLD
				;462	                MOV     A,Key33Threshold
				;463	                MOV     _GLOBE_VARIES[35],A
				;464	                endif
				;465	
				;466	                if      TouchKeyAmount > 33
				;467	                ;-KEY34 THRESHOLD
				;468	                MOV     A,Key34Threshold
				;469	                MOV     _GLOBE_VARIES[36],A
				;470	                endif
				;471	
				;472	                if      TouchKeyAmount > 34
				;473	                ;-KEY35 THRESHOLD
				;474	                MOV     A,Key35Threshold
				;475	                MOV     _GLOBE_VARIES[37],A
				;476	                endif
				;477	
				;478	                if      TouchKeyAmount > 35
				;479	                ;-KEY36 THRESHOLD
				;480	                MOV     A,Key36Threshold
				;481	                MOV     _GLOBE_VARIES[38],A
				;482	                endif
				;483	
				;484	
				;485	                RET
0599	0003	ret
059A	0A0D	sub     a, DH
059B	0A0D	sub     a, DH
059C	0A0D	sub     a, DH
059D	4F48	dc	04F48H
059E	544C	inca    AppData[21]
059F	4B45	dc	04B45H
05A0	4220	sub     a, __ptm0ah[52]
05A1	3853	snz     M1SOF0
05A2	4432	xor     a, __ptm0ah[70]
05A3	3032	set     __tmpc[2].0
05A4	5520	deca    __ptm0ah[52]
05A5	7261	set     r110.4
05A6	2074	call    L0074
05A7	6E69	jmp     E69H
05A8	7469	clr     r714.0
05A9	6169	call    L0969
05AA	206C	call    L006C
05AB	6F64	jmp     F64H
05AC	656E	call    D6EH
05AD	2121	call    L0121
05AE	0D21	or      a, 21H
05AF	000A	dc	0000AH
				@ROMDATA_BASE .SECTION 'CODE'
				@ROMDATA_BASE .SECTION 'CODE'
05B0	0002	halt
05B1	00D4	mov     TKM1C1, a
05B2	0000	nop
05B3	0000	nop
				;486	
				;487	
				;488	
				;489	
				;490	                END
				;491	
				;492	
				;493	
				;file F:\SVNRepo\Project\BS82D20A_AOPU_5KEY\USER_PROGRAM\USER_PROGRAM.C
				;1	
				;2	#include    "USER_PROGRAM.H"  
				;3	
				;4	//==============================================
				;5	//**********************************************
				;6	//==============================================
				;7	//#pragma vector  Interrupt_Extemal        @ 0x04
				;8	//void Interrupt_Extemal()
				;9	//{
				;10	//_nop();	
				;11	//	
				;12	//}
				;13	
				;14	DEFINE_ISR (Interrupt_Extemal, 0x04)
				;15	{
				@Interrupt_Extemal_code .SECTION 'CODE'
0004	40DF	mov     r104, a
0005	070A	mov     a, STATUS
0006	40E0	mov     r204, a
0007	2DB4	jmp     _Interrupt_Extemal
				@dummy4 .SECTION 'CODE'
					----
					----
				;16		GCC_NOP();	
				_Interrupt_Extemal:
				_Interrupt_Extemal:
05B4	0000	nop
05B5	4760	mov     a, r204
05B6	008A	mov     STATUS, a
05B7	475F	mov     a, r104
05B8	0004	reti
				;17	}
				;18	
				;19	
				;20	
				;21	/*******************************************************************
				;22	@CTM0 P中断
				;23	*******************************************************************/	
				;24	DEFINE_ISR (Interrupt_CTM0P, 0x10)
				;25	{
				@Interrupt_CTM0P_code .SECTION 'CODE'
0010	40E1	mov     r110, a
0011	070A	mov     a, STATUS
0012	40E2	mov     r210, a
0013	2DB9	jmp     _Interrupt_CTM0P
				;26		GCC_NOP();	
				_Interrupt_CTM0P:
				_Interrupt_CTM0P:
05B9	0000	nop
05BA	4762	mov     a, r210
05BB	008A	mov     STATUS, a
05BC	4761	mov     a, r110
05BD	0004	reti
				;27	//	DebugString("p");
				;28	}
				;29	
				;30	/*******************************************************************
				;31	@CTM0 A中断
				;32	*******************************************************************/	
				;33	DEFINE_ISR (Interrupt_CTM0A, 0x14)
				;34	{//5ms
				@Interrupt_CTM0A_code .SECTION 'CODE'
				@dummy16 .SECTION 'CODE'
0014	40E3	mov     r114, a
0015	0704	mov     a, BP
0016	40E4	mov     r214, a
0017	2DBE	jmp     _Interrupt_CTM0A
				_Interrupt_CTM0A:
				_Interrupt_CTM0A:
05BE	070A	mov     a, STATUS
05BF	40E5	mov     r314, a
05C0	0703	mov     a, MP1
05C1	40E6	mov     r414, a
05C2	0701	mov     a, MP0
05C3	40E7	mov     r514, a
05C4	0707	mov     a, TBLP
05C5	40E8	mov     r614, a
05C6	0709	mov     a, TBHP
05C7	40E9	mov     r714, a
				;35		//static u8 tickCnt = 0;
				;36		//static u16 rtcCnt = 0;
				;37		static volatile u8 tickCnt __attribute__((at(0x480)));
				;38		static volatile u16 rtcCnt __attribute__((at(0x484)));
				;39		static volatile u8 misCnt __attribute__((at(0x488)));
				;40		
				;41		GCC_NOP();	
05C8	0000	nop
				;42		_ctma0f = 0;
05C9	368F	clr     CTMA0F
				;43	
				;44		if(++rtcCnt >= 200)
05CA	0F84	mov     a, 84H
05CB	0083	mov     MP1, a
05CC	0F04	mov     a, 4H
05CD	0081	mov     MP0, a
05CE	0701	mov     a, MP0
05CF	0084	mov     BP, a
05D0	0702	mov     a, [02H]
05D1	40EA	mov     rb14, a
05D2	1483	inc     MP1
05D3	0702	mov     a, [02H]
05D4	40EB	mov     rc14, a
05D5	54EA	inc     rb14
05D6	3D0A	sz      Z
05D7	54EB	inc     rc14
05D8	0F84	mov     a, 84H
05D9	0083	mov     MP1, a
05DA	0F04	mov     a, 4H
05DB	0081	mov     MP0, a
05DC	0701	mov     a, MP0
05DD	0084	mov     BP, a
05DE	476A	mov     a, rb14
05DF	0082	mov     [02H], a
05E0	1483	inc     MP1
05E1	476B	mov     a, rc14
05E2	0082	mov     [02H], a
05E3	0FC7	mov     a, C7H
05E4	426A	sub     a, rb14
05E5	0F00	mov     a, 0H
05E6	526B	sbc     a, rc14
05E7	3C0A	sz      C
05E8	2DF4	jmp     _L4
				;45		{//1s
				;46			rtcCnt = 0;
05E9	0F84	mov     a, 84H
05EA	0083	mov     MP1, a
05EB	0F04	mov     a, 4H
05EC	0081	mov     MP0, a
05ED	0701	mov     a, MP0
05EE	0084	mov     BP, a
05EF	1F02	clr     [02H]
05F0	1483	inc     MP1
05F1	1F02	clr     [02H]
				;47			AppData.sysRTC++;
05F2	54CD	inc     AppData[22]
				;48			AppTimerRun();
05F3	2737	call    _AppTimerRun
				;49	#if SELF_TEST_EN
				;50			selftest();
				;51			selftest_dec_counter();
				;52	#endif
				;53		}
				;54		
				;55		if(++tickCnt >= 20)
				_L4:
05F4	0F80	mov     a, 80H
05F5	0083	mov     MP1, a
05F6	0F04	mov     a, 4H
05F7	0081	mov     MP0, a
05F8	0701	mov     a, MP0
05F9	0084	mov     BP, a
05FA	0702	mov     a, [02H]
05FB	40F5	mov     _Interrupt_CTM0A_2, a
05FC	5475	inca    _Interrupt_CTM0A_2
05FD	40EC	mov     ra14, a
05FE	0701	mov     a, MP0
05FF	0084	mov     BP, a
0600	476C	mov     a, ra14
0601	0082	mov     [02H], a
0602	0F13	mov     a, 13H
0603	426C	sub     a, ra14
0604	3C0A	sz      C
0605	2E0E	jmp     _L5
				;56		{//100ms
				;57			tickCnt = 0;
0606	0701	mov     a, MP0
0607	0084	mov     BP, a
0608	0F00	mov     a, 0H
0609	0082	mov     [02H], a
				;58			AppData.sysTick++;
060A	54BD	inc     AppData[6]
060B	3D0A	sz      Z
060C	54BE	inc     AppData[7]
				;59			PeripheralSet();
060D	269A	call    _PeripheralSet
				;60		}
				;61		
				;62		if(++misCnt >= 2)
				_L5:
060E	0F88	mov     a, 88H
060F	0083	mov     MP1, a
0610	0F04	mov     a, 4H
0611	0081	mov     MP0, a
0612	0701	mov     a, MP0
0613	0084	mov     BP, a
0614	0702	mov     a, [02H]
0615	40F5	mov     _Interrupt_CTM0A_2, a
0616	5475	inca    _Interrupt_CTM0A_2
0617	40EC	mov     ra14, a
0618	0701	mov     a, MP0
0619	0084	mov     BP, a
061A	476C	mov     a, ra14
061B	0082	mov     [02H], a
061C	0F01	mov     a, 1H
061D	426C	sub     a, ra14
061E	3C0A	sz      C
061F	2E26	jmp     _L3
				;63		{//10ms
				;64			misCnt = 0;
0620	0701	mov     a, MP0
0621	0084	mov     BP, a
0622	0F00	mov     a, 0H
0623	0082	mov     [02H], a
				;65			KeyScan();
0624	6148	call    _KeyScan
				;66			BuzzIsr();
0625	631A	call    _BuzzIsr
				_L3:
0626	4764	mov     a, r214
0627	0084	mov     BP, a
0628	4765	mov     a, r314
0629	008A	mov     STATUS, a
062A	4766	mov     a, r414
062B	0083	mov     MP1, a
062C	4767	mov     a, r514
062D	0081	mov     MP0, a
062E	4768	mov     a, r614
062F	0087	mov     TBLP, a
0630	4769	mov     a, r714
0631	0089	mov     TBHP, a
0632	1D05	tabrd   ACC
0633	4763	mov     a, r114
0634	0004	reti
				;67		}
				;68	}
				;69	
				;70	DEFINE_ISR (Interrupt_PTM1A, 0x18)
				;71	{
				@Interrupt_PTM1A_code .SECTION 'CODE'
				@dummy20 .SECTION 'CODE'
0018	40ED	mov     r118, a
0019	070A	mov     a, STATUS
001A	40EE	mov     r218, a
001B	2E35	jmp     _Interrupt_PTM1A
				L001C:
				@dummy24 .SECTION 'CODE'
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
				L006C:
					----
					----
					----
					----
					----
					----
					----
					----
				L0074:
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
				L00D3:
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
				L0121:
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
				L04FF:
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
					----
				;72		_ptma0f = 0;
				_Interrupt_PTM1A:
				_Interrupt_PTM1A:
0635	378F	clr     PTMA0F
0636	476E	mov     a, r218
0637	008A	mov     STATUS, a
0638	476D	mov     a, r118
0639	0004	reti
				;73	}
				;74	
				;75	
				;76	//==============================================
				;77	//**********************************************
				;78	//==============================================
				;79	void USER_PROGRAM_INITIAL()
				;80	{
				;81	  _papu=0xff;
				_USER_PROGRAM_INITIAL:
				_USER_PROGRAM_INITIAL:
063A	1F96	set     PAPU
				;82	  _pac=0;	
063B	1F15	clr     PAC
				;83	  _pa=0;	
063C	1F14	clr     PA
				;84	  
				;85	  _pac4 = 1;
063D	3215	set     PAC4
				;86		
				;87	  _pcpu=0xff;
063E	1FBB	set     PCPU
				;88	  _pcc=0;	
063F	1F3A	clr     PCC
				;89	  _pc=0;
0640	1F39	clr     PC
				;90	  
				;91	  _pbpu=0xff;
0641	1FA2	set     PBPU
				;92	  _pbc=0;
0642	1F21	clr     PBC
				;93	  _pb=0;
0643	1F20	clr     PB
				;94	  
				;95	  _pdpu=0xff;
0644	1FC3	set     PDPU
				;96	  _pdc=0;
0645	1F42	clr     PDC
				;97	  _pd=0;
0646	1F41	clr     PD
				;98	  //////////////////////
				;99	  
				;100	#if UART_ENABLE
				;101	  UartInitial();
				;102	#endif
				;103	  AppMainInit();
0647	2652	call    _AppMainInit
0648	0003	ret
				;104	}
				;105	
				;106	//==============================================
				;107	//**********************************************
				;108	//==============================================
				;109	void USER_PROGRAM()
				;110	{
				;111		GET_KEY_BITMAP();
				_USER_PROGRAM:
				_USER_PROGRAM:
0649	24FF	call    L04FF
				;112		AppData.keyMap[0] = DATA_BUF[0];
064A	4717	mov     a, __ptm0ah[43]
064B	40BA	mov     AppData[3], a
				;113		AppData.keyMap[1] = DATA_BUF[1];
064C	4718	mov     a, __ptm0ah[44]
064D	40BB	mov     AppData[4], a
				;114		AppData.keyMap[2] = DATA_BUF[2];
064E	4719	mov     a, __ptm0ah[45]
064F	40BC	mov     AppData[5], a
				;115		AppTask();
0650	27C7	call    _AppTask
0651	0003	ret
				;116	}
				;117	
				;118	
				;119	
				;file F:\SVNRepo\Project\BS82D20A_AOPU_5KEY\USER_PROGRAM\key.c
				;1	
				;2	#include    "USER_PROGRAM.H" 
				;3	
				;4	
				;5	u16 keyCounter = 0;		//按键扫描计数
				;6	
				;7	void KeyInit(void)
				;8	{
				_KeyInit:
				_KeyInit:
000A	0003	ret
				;9	
				;10	}
				;11	
				;12	
				;13	
				;14	u16 readKey(void)
				;15	{
				;16		u16 key = 0X0000;
091B	5F6A	clr     rb14
091C	5F6B	clr     rc14
091D	6921	jmp     _L3
				;17	
				;18	
				;19	
				;20		if(K4_PRESS)
				_readKey:
				_readKey:
0919	7D3C	sz      AppData[5].2
091A	691E	jmp     _L8
				;21		{
				;22			key |= KEY_K4;
				_L8:
091E	0F10	mov     a, 10H
091F	40EA	mov     rb14, a
0920	5F6B	clr     rc14
				;23		}
				;24	
				;25		if(K3_PRESS)
				_L3:
0921	473A	mov     a, AppData[3]
0922	40F3	mov     _readKey_2, a
0923	79F3	snz     _readKey_2.3
0924	6929	jmp     _L4
				;26		{
				;27			key |= KEY_K3;
0925	0F00	mov     a, 0H
0926	45EB	orm     a, rc14
0927	0F08	mov     a, 8H
0928	45EA	orm     a, rb14
				;28		}
				;29	
				;30		if(K2_PRESS)
				_L4:
0929	7973	snz     _readKey_2.2
092A	692F	jmp     _L5
				;31		{
				;32			key |= KEY_K2;
092B	0F00	mov     a, 0H
092C	45EB	orm     a, rc14
092D	0F01	mov     a, 1H
092E	45EA	orm     a, rb14
				;33		}
				;34	
				;35		if(K1_PRESS)
				_L5:
092F	78F3	snz     _readKey_2.1
0930	6935	jmp     _L6
				;36		{
				;37			key |= KEY_K1;
0931	0F00	mov     a, 0H
0932	45EB	orm     a, rc14
0933	0F02	mov     a, 2H
0934	45EA	orm     a, rb14
				;38		}
				;39	
				;40		if(K0_PRESS)
				_L6:
0935	7873	snz     _readKey_2.0
0936	693B	jmp     _L7
				;41		{
				;42			key |= KEY_K0;
0937	0F00	mov     a, 0H
0938	45EB	orm     a, rc14
0939	0F04	mov     a, 4H
093A	45EA	orm     a, rb14
				;43		}
				;44		
				;45		
				;46		
				;47	
				;48		return key;
				;49	}
				_L7:
093B	476A	mov     a, rb14
093C	40EC	mov     ra14, a
093D	476B	mov     a, rc14
093E	40EA	mov     rb14, a
093F	0003	ret
				;50	
				;51	
				;52	/************************************************************
				;53	@
				;54	************************************************************/
				;55	u16 KeyDetect(void)
				;56	{
				;57	  u16 key;
				;58	  
				;59	  key = readKey();
				_KeyDetect:
				_KeyDetect:
0940	6119	call    _readKey
				;60	
				;61	  if(key == 0X0000) key = NO_KEY;
0941	476C	mov     a, ra14
0942	456A	or      a, rb14
0943	390A	snz     Z
0944	6947	jmp     _L23
0945	5FEC	set     ra14
0946	5FEA	set     rb14
				_L23:
0947	0003	ret
				;62	    
				;63	  return key;
				;64	}
				;65	
				;66	/*----------------------------------------------------------------------------*/
				;67	/**@brief 按键检测，每10ms进行一次
				;68	@return 无
				;69	*/
				;70	/*----------------------------------------------------------------------------*/
				;71	void KeyScan(void)
				;72	{
				;73		static u16 keyValue = 0;
				;74	
				;75	  u16 keyTmp = NO_KEY;
				;76	  u16 key_return = NO_KEY;
				;77	  keyTmp = KeyDetect();
				_KeyScan:
				_KeyScan:
0948	6140	call    _KeyDetect
0949	476A	mov     a, rb14
094A	40EB	mov     rc14, a
094B	476C	mov     a, ra14
094C	40EA	mov     rb14, a
				;78	  if(keyTmp == NO_KEY )
094D	476A	mov     a, rb14
094E	466B	and     a, rc14
094F	0B01	add     a, 1H
0950	380A	snz     C
0951	6974	jmp     _L26
				;79	  {
				;80	    if (keyCounter >= KEY_LONG_TIMES)  //长按抬键
0952	4754	mov     a, keyCounter[0]
0953	40F1	mov     rd14, a
0954	4755	mov     a, keyCounter[1]
0955	40F2	mov     re14, a
0956	0FC7	mov     a, C7H
0957	4271	sub     a, rd14
0958	0F00	mov     a, 0H
0959	5272	sbc     a, re14
095A	3C0A	sz      C
095B	6963	jmp     _L27
				;81	    {
				;82	      key_return = keyValue | KEY_LONG_UP;
095C	4757	mov     a, keyValue[1]
095D	0D40	or      a, 40H
095E	40EB	mov     rc14, a
095F	4756	mov     a, keyValue[0]
0960	0D00	or      a, 0H
0961	40EA	mov     rb14, a
0962	696F	jmp     _L28
				;83	    }
				;84	    else if (keyCounter >= KEY_SCAN_TIMES)   //短按抬键
				_L27:
0963	0F02	mov     a, 2H
0964	4271	sub     a, rd14
0965	0F00	mov     a, 0H
0966	5272	sbc     a, re14
0967	3C0A	sz      C
0968	696F	jmp     _L28
				;85	    {
				;86	      key_return = keyValue | KEY_SHORT_UP;
				L0969:
0969	4757	mov     a, keyValue[1]
096A	0D30	or      a, 30H
096B	40EB	mov     rc14, a
096C	4756	mov     a, keyValue[0]
096D	0D00	or      a, 0H
096E	40EA	mov     rb14, a
				;87	    }
				;88	
				;89	    keyValue = keyTmp;
				_L28:
096F	5FD6	set     keyValue[0]
0970	5FD7	set     keyValue[1]
				;90	    keyCounter = 0;  
0971	5F54	clr     keyCounter[0]
0972	5F55	clr     keyCounter[1]
0973	69A7	jmp     _L29
				;91	  }
				;92	  else if(keyTmp != keyValue)
				_L26:
0974	476A	mov     a, rb14
0975	4456	xor     a, keyValue[0]
0976	476B	mov     a, rc14
0977	3D0A	sz      Z
0978	4457	xor     a, keyValue[1]
0979	3D0A	sz      Z
097A	6982	jmp     _L30
				;93	  {
				;94	    keyValue = keyTmp;
097B	476A	mov     a, rb14
097C	40D6	mov     keyValue[0], a
097D	476B	mov     a, rc14
097E	40D7	mov     keyValue[1], a
				;95	    keyCounter = 0;
097F	5F54	clr     keyCounter[0]
0980	5F55	clr     keyCounter[1]
0981	69B0	jmp     _L25
				;96	  }	
				;97	  else
				;98	  {
				;99	    keyCounter++;
				_L30:
0982	0F01	mov     a, 1H
0983	4354	add     a, keyCounter[0]
0984	40F1	mov     rd14, a
0985	0F00	mov     a, 0H
0986	5355	adc     a, keyCounter[1]
0987	40F2	mov     re14, a
0988	4771	mov     a, rd14
0989	40D4	mov     keyCounter[0], a
098A	4772	mov     a, re14
098B	40D5	mov     keyCounter[1], a
				;100	    if (keyCounter == KEY_SCAN_TIMES)			//去抖
098C	4771	mov     a, rd14
098D	0C03	xor     a, 3H
098E	4572	or      a, re14
098F	3D0A	sz      Z
0990	69AC	jmp     _L32
				;101	    {
				;102	      key_return = keyValue;
				;103	    }
				;104	    else if (keyCounter == KEY_LONG_TIMES)				//长按
0991	4771	mov     a, rd14
0992	0CC8	xor     a, C8H
0993	4572	or      a, re14
0994	390A	snz     Z
0995	699B	jmp     _L33
				;105	    {
				;106	      key_return = keyValue | KEY_LONG;
0996	0F10	mov     a, 10H
0997	45EB	orm     a, rc14
0998	0F00	mov     a, 0H
0999	45EA	orm     a, rb14
099A	69A7	jmp     _L29
				;107	    }
				;108	    else if (keyCounter == (KEY_LONG_TIMES + KEY_HOLD_TIMES) )			//连按
				_L33:
099B	4771	mov     a, rd14
099C	0CFA	xor     a, FAH
099D	4572	or      a, re14
099E	390A	snz     Z
099F	69B0	jmp     _L25
				;109	    {
				;110	      key_return = keyValue | KEY_HOLD;
09A0	0F20	mov     a, 20H
09A1	45EB	orm     a, rc14
09A2	0F00	mov     a, 0H
09A3	45EA	orm     a, rb14
				;111	      keyCounter = KEY_LONG_TIMES;
09A4	0FC8	mov     a, C8H
09A5	40D4	mov     keyCounter[0], a
09A6	5F55	clr     keyCounter[1]
				;112	    }
				;113	  }
				;114	  if (key_return != NO_KEY)
				_L29:
09A7	476A	mov     a, rb14
09A8	466B	and     a, rc14
09A9	0B01	add     a, 1H
09AA	3C0A	sz      C
09AB	69B0	jmp     _L25
				;115	  {
				;116			//key is here
				;117			AppData.keyMsg = key_return;
				_L32:
09AC	476A	mov     a, rb14
09AD	40B8	mov     AppData[1], a
09AE	476B	mov     a, rc14
09AF	40B9	mov     AppData[2], a
				_L25:
09B0	0003	ret
				;118			//UART_SendByte(key_return);
				;119	  }
				;120	
				;121	}
				;122	
				;123	
				;124	u16 GetKeyMsg(void)
				;125	{
				;126		u16 key;
				;127		
				;128		key = AppData.keyMsg;
				_GetKeyMsg:
				_GetKeyMsg:
09B1	4738	mov     a, AppData[1]
09B2	40DB	mov     ra, a
09B3	4739	mov     a, AppData[2]
09B4	40DC	mov     rb, a
				;129		
				;130		if(AppData.keyMsg != NO_KEY)
09B5	475B	mov     a, ra
09B6	465C	and     a, rb
09B7	0B01	add     a, 1H
09B8	3C0A	sz      C
09B9	69BC	jmp     _L42
				;131		{
				;132			AppData.keyMsg = NO_KEY;
09BA	5FB8	set     AppData[1]
09BB	5FB9	set     AppData[2]
				_L42:
09BC	0003	ret
				;133		}
				;134		
				;135		return key;	
				;136	}
				;137	
				;file F:\SVNRepo\Project\BS82D20A_AOPU_5KEY\USER_PROGRAM\led.c
				;1	
				;2	#include    "USER_PROGRAM.H"
				;3	 
				;4	//#define LED_STANDBY_ON()					LED4ON();LED5OFF()
				;5	//#define LED_STANDBY_OFF()					LED4OFF();LED5ON()
				;6	
				;7	void LedInit(void)
				;8	{
				_LedInit:
				_LedInit:
000B	0003	ret
					----
					----
					----
					----
				;9	
				;10	}
				;11	
				;12	void LED_STANDBY_ON(void)
				;13	{
				;14		LED4OFF();
				_LED_STANDBY_ON:
				_LED_STANDBY_ON:
09BD	3639	clr     PC4
				;15		LED5ON();
09BE	36B9	clr     PC5
09BF	0003	ret
				;16	}
				;17	
				;18	void LED_STANDBY_OFF(void)
				;19	{
				;20		LED4ON();
				_LED_STANDBY_OFF:
				_LED_STANDBY_OFF:
09C0	3239	set     PC4
				;21		LED5OFF();
09C1	32B9	set     PC5
09C2	0003	ret
				;22	}
				;23	
				;24	void LedAllOn(void)
				;25	{
				;26		LED0ON();
				_LedAllOn:
				_LedAllOn:
09C3	3039	set     PC0
				;27		LED1ON();
09C4	30B9	set     PC1
				;28		LED2ON();
09C5	3139	set     PC2
				;29		LED3ON();
09C6	31B9	set     PC3
				;30		LED4ON();
09C7	3239	set     PC4
				;31		LED5ON();
09C8	36B9	clr     PC5
09C9	0003	ret
				;32	}
				;33	
				;34	void LedAllOff(void)
				;35	{
				;36		LED0OFF();
				_LedAllOff:
				_LedAllOff:
09CA	3439	clr     PC0
				;37		LED1OFF();
09CB	34B9	clr     PC1
				;38		LED2OFF();
09CC	3539	clr     PC2
				;39		LED3OFF();
09CD	35B9	clr     PC3
				;40		LED4OFF();
09CE	3639	clr     PC4
				;41		LED5OFF();
09CF	32B9	set     PC5
09D0	0003	ret
				;42	}
				;43	
				;44	////LED7
				;45	//#define LED0ON() 	LED0_PORT = 1
				;46	//#define LED0OFF() LED0_PORT = 0
				;47	////LED5
				;48	//#define LED1ON() 	LED1_PORT = 1
				;49	//#define LED1OFF() LED1_PORT = 0
				;50	////LED3
				;51	//#define LED2ON() 	LED2_PORT = 1
				;52	//#define LED2OFF() LED2_PORT = 0
				;53	////LED1
				;54	//#define LED3ON() 	LED3_PORT = 1
				;55	//#define LED3OFF() LED3_PORT = 0
				;56	////LED9
				;57	//#define LED4ON() 	LED4_PORT = 1
				;58	//#define LED4OFF() LED4_PORT = 0
				;59	//#define QDP9016A 	0X00
				;60	//#define QDP9016B 	0X01
				;61	//#define TKG_18A 	0X02
				;62	//#define TKG_18B 	0X03
				;63	//#define TKG_18C 	0X04
				;64	//#define TKG_18D 	0X05
				;65	void LedShowModle(void)
				;66	{
				;67		GetKeyMsg();
				_LedShowModle:
				_LedShowModle:
09D1	61B1	call    _GetKeyMsg
				;68		
				;69		LED5OFF();
09D2	32B9	set     PC5
				;70	#if (MODLE_TYPE==QDP9016A)
				;71		LED4ON();
				;72		LED3OFF();
				;73		LED2OFF();
				;74		LED1OFF();
				;75		LED0OFF();
				;76	#endif
				;77	
				;78	#if (MODLE_TYPE==QDP9016B)
				;79		LED4ON();
				;80		LED0ON();
				;81		LED3OFF();
				;82		LED2OFF();
				;83		LED1OFF();
				;84	#endif
				;85	
				;86	#if (MODLE_TYPE==TKG_18A)
				;87		LED2ON();
				;88		LED0ON();
				;89		LED3OFF();
				;90		LED4OFF();
				;91		LED1OFF();
				;92	#endif
				;93	
				;94	
				;95	#if (MODLE_TYPE==TKG_18B)
				;96		LED2ON();
				;97		LED0ON();
				;98		LED3ON();
				;99		LED4OFF();
				;100		LED1OFF();
				;101	#endif
				;102	
				;103	#if (MODLE_TYPE==TKG_18C)
				;104		LED2ON();
09D3	3139	set     PC2
				;105		LED3ON();
09D4	31B9	set     PC3
				;106		LED0ON();
09D5	3039	set     PC0
				;107		LED1ON();
09D6	30B9	set     PC1
				;108		LED4ON();
09D7	3239	set     PC4
09D8	0003	ret
				;109	#endif
				;110	
				;111	#if (MODLE_TYPE==TKG_18D)
				;112	
				;113	#endif
				;114	
				;115	}
				;116	
				;117	u8 LedShowCycle(void)
				;118	{
				;119		static u8 led_state = 0;
				;120		
				;121		GetKeyMsg();
				_LedShowCycle:
				_LedShowCycle:
09D9	61B1	call    _GetKeyMsg
				;122		if(APP_TIMER_Expired(AppData.gTimer,5))
09DA	0F05	mov     a, 5H
09DB	40F8	mov     seconds, a
09DC	5F79	clr     seconds[1]
09DD	473F	mov     a, AppData[8]
09DE	40F6	mov     byte, a
09DF	4740	mov     a, AppData[9]
09E0	40F7	mov     buf, a
09E1	6348	call    _APP_TIMER_Expired
09E2	40DB	mov     ra, a
09E3	50DB	sz      ra
09E4	69E6	jmp     _LI1
09E5	6A32	jmp     _L8
				;123		{
				;124			APP_TIMER_Set(&AppData.gTimer);
				_LI1:
09E6	0FBF	mov     a, BFH
09E7	40F6	mov     byte, a
09E8	0F00	mov     a, 0H
09E9	40F7	mov     buf, a
09EA	6359	call    _APP_TIMER_Set
				;125			
				;126			if(led_state == 0)
09EB	475A	mov     a, led_state[0]
09EC	40FA	mov     key, a
09ED	50FA	sz      key
09EE	69F2	jmp     _L9
				;127			{
				;128				LedAllOff();
09EF	61CA	call    _LedAllOff
				;129				LED5ON();
09F0	36B9	clr     PC5
09F1	6A2C	jmp     _L10
				;130			}
				;131			else if(led_state == 1)
				_L9:
09F2	577A	sdza    key
09F3	69F7	jmp     _L11
				;132			{
				;133				LedAllOff();
09F4	61CA	call    _LedAllOff
				;134				LED4ON();
09F5	3239	set     PC4
09F6	6A2C	jmp     _L10
				;135			}
				;136			else if(led_state == 2)
				_L11:
09F7	477A	mov     a, key
09F8	0A02	sub     a, 2H
09F9	390A	snz     Z
09FA	69FD	jmp     _L12
				;137			{
				;138				LedAllOff();
				_L14:
09FB	61CA	call    _LedAllOff
09FC	6A2C	jmp     _L10
				;139			}
				;140			else if(led_state == 3)
				_L12:
09FD	477A	mov     a, key
09FE	0A03	sub     a, 3H
09FF	390A	snz     Z
0A00	6A04	jmp     _L13
				;141			{
				;142				LedAllOff();
0A01	61CA	call    _LedAllOff
				;143				LED0ON();
0A02	3039	set     PC0
0A03	6A2C	jmp     _L10
				;144			}
				;145			else if(led_state == 4)
				_L13:
0A04	477A	mov     a, key
0A05	0A04	sub     a, 4H
0A06	3D0A	sz      Z
0A07	69FB	jmp     _L14
				;146			{
				;147				LedAllOff();
				;148			}
				;149			else if(led_state == 5)
0A08	477A	mov     a, key
0A09	0A05	sub     a, 5H
0A0A	390A	snz     Z
0A0B	6A0F	jmp     _L15
				;150			{
				;151				LedAllOff();
0A0C	61CA	call    _LedAllOff
				;152				LED1ON();
0A0D	30B9	set     PC1
0A0E	6A2C	jmp     _L10
				;153			}
				;154			else if(led_state == 6)
				_L15:
0A0F	477A	mov     a, key
0A10	0A06	sub     a, 6H
0A11	3D0A	sz      Z
0A12	69FB	jmp     _L14
				;155			{
				;156				LedAllOff();
				;157			}
				;158			else if(led_state == 7)
0A13	477A	mov     a, key
0A14	0A07	sub     a, 7H
0A15	390A	snz     Z
0A16	6A1A	jmp     _L16
				;159			{
				;160				LedAllOff();
0A17	61CA	call    _LedAllOff
				;161				LED2ON();
0A18	3139	set     PC2
0A19	6A2C	jmp     _L10
				;162			}
				;163			else if(led_state == 8)
				_L16:
0A1A	477A	mov     a, key
0A1B	0A08	sub     a, 8H
0A1C	3D0A	sz      Z
0A1D	69FB	jmp     _L14
				;164			{
				;165				LedAllOff();
				;166			}
				;167			else if(led_state == 9)
0A1E	477A	mov     a, key
0A1F	0A09	sub     a, 9H
0A20	390A	snz     Z
0A21	6A25	jmp     _L17
				;168			{
				;169				LedAllOff();
0A22	61CA	call    _LedAllOff
				;170				LED3ON();
0A23	31B9	set     PC3
0A24	6A2C	jmp     _L10
				;171			}
				;172			else if(led_state == 10)
				_L17:
0A25	477A	mov     a, key
0A26	0A0A	sub     a, AH
0A27	3D0A	sz      Z
0A28	69FB	jmp     _L14
0A29	0A01	sub     a, 1H
0A2A	3D0A	sz      Z
0A2B	6A30	jmp     _L18
				;173			{
				;174				LedAllOff();
				;175			}
				;176			else if(led_state == 11)
				;177			{
				;178				return 1;
				_L18:
0A30	0F01	mov     a, 1H
0A31	40DB	mov     ra, a
				;179			}
				;180			led_state++;
				_L10:
0A2C	547A	inca    key
0A2D	40DA	mov     led_state[0], a
				;181		}	
				;182		
				;183		return 0;
0A2E	5F5B	clr     ra
0A2F	6A32	jmp     _L8
				;184	}
				_L8:
0A32	475B	mov     a, ra
0A33	0003	ret
				;185	
				;186	u8 JKShowCycle(void)
				;187	{
				;188		static u8 led_state = 0;
				;189		
				;190		GetKeyMsg();
				_JKShowCycle:
				_JKShowCycle:
0A34	61B1	call    _GetKeyMsg
				;191		if(APP_TIMER_Expired(AppData.gTimer,20))
0A35	0F14	mov     a, 14H
0A36	40F8	mov     seconds, a
0A37	5F79	clr     seconds[1]
0A38	473F	mov     a, AppData[8]
0A39	40F6	mov     byte, a
0A3A	4740	mov     a, AppData[9]
0A3B	40F7	mov     buf, a
0A3C	6348	call    _APP_TIMER_Expired
0A3D	40DB	mov     ra, a
0A3E	50DB	sz      ra
0A3F	6A41	jmp     _LI2
0A40	6A8C	jmp     _L36
				;192		{
				;193			APP_TIMER_Set(&AppData.gTimer);
				_LI2:
0A41	0FBF	mov     a, BFH
0A42	40F6	mov     byte, a
0A43	0F00	mov     a, 0H
0A44	40F7	mov     buf, a
0A45	6359	call    _APP_TIMER_Set
				;194			
				;195			LED_STANDBY_OFF();
0A46	61C0	call    _LED_STANDBY_OFF
				;196			
				;197			if(led_state == 0)
0A47	4759	mov     a, led_state[0]
0A48	40FA	mov     key, a
0A49	50FA	sz      key
0A4A	6A4E	jmp     _L37
				;198			{
				;199				LED_LIGHT_HEATING_OFF();
0A4B	3439	clr     PC0
				;200				JK_LIGHT_HEATING_OFF();
0A4C	3720	clr     PB6
0A4D	6A5F	jmp     _L48
				;201				
				;202				LED_AIR_CHANGE_OFF();
				;203				JK_AIR_CHANGE_OFF();
				;204				
				;205				LED_AIR_HEATING_OFF();
				;206				JK_AIR_HEATING_OFF();
				;207				
				;208				LED_AIR_BLOW_ON();
				;209				JK_AIR_BLOW_ON();
				;210			}
				;211			else if(led_state == 1)
				_L37:
0A4E	577A	sdza    key
0A4F	6A59	jmp     _L39
				;212			{
				;213				LED_LIGHT_HEATING_OFF();
0A50	3439	clr     PC0
				;214				JK_LIGHT_HEATING_OFF();
0A51	3720	clr     PB6
				;215				
				;216				LED_AIR_CHANGE_OFF();
0A52	3539	clr     PC2
				;217				JK_AIR_CHANGE_OFF();
0A53	35C1	clr     PD3
				;218				
				;219				LED_AIR_HEATING_ON();
0A54	30B9	set     PC1
				;220				JK_AIR_HEATING_ON();
0A55	33A0	set     PB7
				;221				
				;222				LED_AIR_BLOW_ON();
				_L46:
0A56	31B9	set     PC3
				;223				JK_AIR_BLOW_ON();
0A57	3141	set     PD2
0A58	6A89	jmp     _L38
				;224			}
				;225			else if(led_state == 2)
				_L39:
0A59	477A	mov     a, key
0A5A	0A02	sub     a, 2H
0A5B	390A	snz     Z
0A5C	6A64	jmp     _L40
				;226			{
				;227				LED_LIGHT_HEATING_ON();
0A5D	3039	set     PC0
				;228				JK_LIGHT_HEATING_ON();
0A5E	3320	set     PB6
				;229				
				;230				LED_AIR_CHANGE_OFF();
				_L48:
0A5F	3539	clr     PC2
				;231				JK_AIR_CHANGE_OFF();
0A60	35C1	clr     PD3
				;232				
				;233				LED_AIR_HEATING_OFF();
0A61	34B9	clr     PC1
				;234				JK_AIR_HEATING_OFF();
0A62	37A0	clr     PB7
0A63	6A56	jmp     _L46
				;235				
				;236				LED_AIR_BLOW_ON();
				;237				JK_AIR_BLOW_ON();
				;238			}
				;239			else if(led_state == 3)
				_L40:
0A64	477A	mov     a, key
0A65	0A03	sub     a, 3H
0A66	390A	snz     Z
0A67	6A6D	jmp     _L41
				;240			{
				;241				LED_LIGHT_HEATING_OFF();
0A68	3439	clr     PC0
				;242				JK_LIGHT_HEATING_OFF();
0A69	3720	clr     PB6
				;243				
				;244				LED_AIR_CHANGE_OFF();
0A6A	3539	clr     PC2
				;245				JK_AIR_CHANGE_OFF();
0A6B	35C1	clr     PD3
0A6C	6A75	jmp     _L47
				;246				
				;247				LED_AIR_HEATING_OFF();
				;248				JK_AIR_HEATING_OFF();
				;249				
				;250				LED_AIR_BLOW_OFF();
				;251				JK_AIR_BLOW_OFF();
				;252			}
				;253			else if(led_state == 4)
				_L41:
0A6D	477A	mov     a, key
0A6E	0A04	sub     a, 4H
0A6F	390A	snz     Z
0A70	6A7A	jmp     _L42
				;254			{
				;255				LED_LIGHT_HEATING_OFF();
0A71	3439	clr     PC0
				;256				JK_LIGHT_HEATING_OFF();
0A72	3720	clr     PB6
				;257				
				;258				LED_AIR_CHANGE_ON();
0A73	3139	set     PC2
				;259				JK_AIR_CHANGE_ON();
0A74	31C1	set     PD3
				;260				
				;261				LED_AIR_HEATING_OFF();
				_L47:
0A75	34B9	clr     PC1
				;262				JK_AIR_HEATING_OFF();
0A76	37A0	clr     PB7
				;263				
				;264				LED_AIR_BLOW_OFF();
0A77	35B9	clr     PC3
				;265				JK_AIR_BLOW_OFF();
0A78	3541	clr     PD2
0A79	6A89	jmp     _L38
				;266			}
				;267			else if(led_state == 5)
				_L42:
0A7A	477A	mov     a, key
0A7B	0A05	sub     a, 5H
0A7C	390A	snz     Z
0A7D	6A89	jmp     _L38
				;268			{
				;269				LED_LIGHT_HEATING_OFF();
0A7E	3439	clr     PC0
				;270				JK_LIGHT_HEATING_OFF();
0A7F	3720	clr     PB6
				;271				
				;272				LED_AIR_CHANGE_OFF();
0A80	3539	clr     PC2
				;273				JK_AIR_CHANGE_OFF();
0A81	35C1	clr     PD3
				;274				
				;275				LED_AIR_HEATING_OFF();
0A82	34B9	clr     PC1
				;276				JK_AIR_HEATING_OFF();
0A83	37A0	clr     PB7
				;277				
				;278				LED_AIR_BLOW_OFF();
0A84	35B9	clr     PC3
				;279				JK_AIR_BLOW_OFF();
0A85	3541	clr     PD2
				;280				return 1;
0A86	0F01	mov     a, 1H
0A87	40DB	mov     ra, a
0A88	6A8C	jmp     _L36
				;281			}
				;282	
				;283			led_state++;
				_L38:
0A89	547A	inca    key
0A8A	40D9	mov     led_state[0], a
				;284		}	
				;285		
				;286		return 0;
0A8B	5F5B	clr     ra
				;287	}
				_L36:
0A8C	475B	mov     a, ra
0A8D	0003	ret
				;288	
				;289	
				;290	u8 KeyShowCycle(void)
				;291	{
				;292		u16 key;
				;293		static u8  standby = 0;
				;294	
				;295		if(APP_TIMER_Expired(AppData.gTimer,100))
				_KeyShowCycle:
				_KeyShowCycle:
0A8E	0F64	mov     a, 64H
0A8F	40F8	mov     seconds, a
0A90	5F79	clr     seconds[1]
0A91	473F	mov     a, AppData[8]
0A92	40F6	mov     byte, a
0A93	4740	mov     a, AppData[9]
0A94	40F7	mov     buf, a
0A95	6348	call    _APP_TIMER_Expired
0A96	40FC	mov     key[2], a
0A97	50FC	sz      key[2]
0A98	6A9A	jmp     _LI3
0A99	6AA2	jmp     _L50
				;296		{
				;297			APP_TIMER_Set(&AppData.gTimer);
				_LI3:
0A9A	0FBF	mov     a, BFH
0A9B	40F6	mov     byte, a
0A9C	0F00	mov     a, 0H
0A9D	40F7	mov     buf, a
0A9E	6359	call    _APP_TIMER_Set
				;298			return 1;
0A9F	0F01	mov     a, 1H
0AA0	40FC	mov     key[2], a
0AA1	6B13	jmp     _L51
				;299		}
				;300		
				;301		key = GetKeyMsg();
				_L50:
0AA2	61B1	call    _GetKeyMsg
0AA3	475B	mov     a, ra
0AA4	40FA	mov     key[0], a
0AA5	475C	mov     a, rb
0AA6	40FB	mov     key[1], a
				;302		if(key != NO_KEY)
0AA7	475B	mov     a, ra
0AA8	465C	and     a, rb
0AA9	0B01	add     a, 1H
0AAA	3C0A	sz      C
0AAB	6B13	jmp     _L51
				;303		{
				;304			APP_TIMER_Set(&AppData.gTimer);
0AAC	0FBF	mov     a, BFH
0AAD	40F6	mov     byte, a
0AAE	0F00	mov     a, 0H
0AAF	40F7	mov     buf, a
0AB0	6359	call    _APP_TIMER_Set
				;305			switch(key)
0AB1	477A	mov     a, key[0]
0AB2	0C01	xor     a, 1H
0AB3	477B	mov     a, key[1]
0AB4	3D0A	sz      Z
0AB5	0C30	xor     a, 30H
0AB6	3D0A	sz      Z
0AB7	6AF1	jmp     _L52
0AB8	477A	mov     a, key[0]
0AB9	0C02	xor     a, 2H
0ABA	477B	mov     a, key[1]
0ABB	3D0A	sz      Z
0ABC	0C30	xor     a, 30H
0ABD	3D0A	sz      Z
0ABE	6AFF	jmp     _L53
0ABF	477A	mov     a, key[0]
0AC0	0C04	xor     a, 4H
0AC1	477B	mov     a, key[1]
0AC2	3D0A	sz      Z
0AC3	0C30	xor     a, 30H
0AC4	3D0A	sz      Z
0AC5	6B0A	jmp     _L54
0AC6	477A	mov     a, key[0]
0AC7	0C08	xor     a, 8H
0AC8	477B	mov     a, key[1]
0AC9	3D0A	sz      Z
0ACA	0C30	xor     a, 30H
0ACB	3D0A	sz      Z
0ACC	6AD5	jmp     _L55
0ACD	477A	mov     a, key[0]
0ACE	0C10	xor     a, 10H
0ACF	477B	mov     a, key[1]
0AD0	3D0A	sz      Z
0AD1	0C30	xor     a, 30H
0AD2	390A	snz     Z
0AD3	6B13	jmp     _L51
0AD4	6AE3	jmp     _L65
				;306			{
				;307				
				;308				case PS_K3:
				;309					if(!(AppData.func&FUNC_AIR_BLOW))
				_L55:
0AD5	474F	mov     a, AppData[24]
0AD6	40DB	mov     ra, a
0AD7	7C5B	sz      ra.0
0AD8	6ADE	jmp     _L57
				;310					{
				;311						EnableAirBlow();
0AD9	705B	set     ra.0
0ADA	475B	mov     a, ra
0ADB	40CF	mov     AppData[24], a
				;312						LED_AIR_BLOW_ON();
0ADC	31B9	set     PC3
0ADD	6B13	jmp     _L51
				;313					}
				;314					else
				;315					{
				;316						DisableAirBlow();
				_L57:
0ADE	745B	clr     ra.0
0ADF	475B	mov     a, ra
0AE0	40CF	mov     AppData[24], a
				;317						LED_AIR_BLOW_OFF();
0AE1	35B9	clr     PC3
0AE2	6B13	jmp     _L51
				;318					}
				;319					break;
				;320					
				;321				case PS_K4:
				;322					if(!(AppData.func&FUNC_AIR_CHANGE))
				_L65:
0AE3	474F	mov     a, AppData[24]
0AE4	40DB	mov     ra, a
0AE5	7CDB	sz      ra.1
0AE6	6AEC	jmp     _L58
				;323					{
				;324						EnableAirChange();
0AE7	70DB	set     ra.1
0AE8	475B	mov     a, ra
0AE9	40CF	mov     AppData[24], a
				;325						LED_AIR_CHANGE_ON();
0AEA	3139	set     PC2
0AEB	6B13	jmp     _L51
				;326					}
				;327					else
				;328					{
				;329						DisableAirChange();
				_L58:
0AEC	74DB	clr     ra.1
0AED	475B	mov     a, ra
0AEE	40CF	mov     AppData[24], a
				;330						LED_AIR_CHANGE_OFF();
0AEF	3539	clr     PC2
0AF0	6B13	jmp     _L51
				;331					}
				;332					break;
				;333				
				;334				case PS_K2:
				;335					if(!(AppData.func&FUNC_AIR_HEATING))
				_L52:
0AF1	474F	mov     a, AppData[24]
0AF2	40DB	mov     ra, a
0AF3	7D5B	sz      ra.2
0AF4	6AFA	jmp     _L59
				;336					{
				;337						EnableAirHeating();
0AF5	715B	set     ra.2
0AF6	475B	mov     a, ra
0AF7	40CF	mov     AppData[24], a
				;338						LED_AIR_HEATING_ON();
0AF8	30B9	set     PC1
0AF9	6B13	jmp     _L51
				;339					}
				;340					else
				;341					{
				;342						DisableAirHeating();
				_L59:
0AFA	755B	clr     ra.2
0AFB	475B	mov     a, ra
0AFC	40CF	mov     AppData[24], a
				;343						LED_AIR_HEATING_OFF();
0AFD	34B9	clr     PC1
0AFE	6B13	jmp     _L51
				;344					}
				;345					break;
				;346				
				;347				case PS_K1:
				;348					if(AppData.funcLightHeating != FUNC_LIGHT_HEATING)
				_L53:
0AFF	4750	mov     a, AppData[25]
0B00	0A10	sub     a, 10H
0B01	3D0A	sz      Z
0B02	6B07	jmp     _L60
				;349					{
				;350						EnableLightHeating();
0B03	0F10	mov     a, 10H
0B04	40D0	mov     AppData[25], a
				;351						LED_LIGHT_HEATING_ON();
0B05	3039	set     PC0
0B06	6B13	jmp     _L51
				;352					}
				;353					else
				;354					{
				;355						DisableLightHeating();
				_L60:
0B07	5F50	clr     AppData[25]
				;356						LED_LIGHT_HEATING_OFF();
0B08	3439	clr     PC0
0B09	6B13	jmp     _L51
				;357					}
				;358					break;
				;359					
				;360					
				;361				case PS_K0:	
				;362					if(standby)
				_L54:
0B0A	50D8	sz      standby[0]
0B0B	6B0D	jmp     _LI4
0B0C	6B10	jmp     _L61
				;363					{
				;364						standby = 0;
				_LI4:
0B0D	5F58	clr     standby[0]
				;365						LED_STANDBY_OFF();
0B0E	61C0	call    _LED_STANDBY_OFF
0B0F	6B13	jmp     _L51
				;366					}
				;367					else
				;368					{
				;369						standby = 1;
				_L61:
0B10	0F01	mov     a, 1H
0B11	40D8	mov     standby[0], a
				;370						LED_STANDBY_ON();
0B12	61BD	call    _LED_STANDBY_ON
				;371					}
				;372					break;			
				;373					
				;374				
				;375				default:
				;376					break;
				;377			}//////end key handle
				;378	
				;379				
				;380		}
				;381		return 0;
				;382	}
				_L51:
0B13	477C	mov     a, key[2]
0B14	0003	ret
				;383	
				;384	void BuzzMs(u8 ms)
				;385	{
				_BuzzMs:
				_BuzzMs:
0B15	40DB	mov     ra, a
				;386		AppData.buzzMs = ms;
0B16	475B	mov     a, ra
0B17	40D2	mov     AppData[27], a
				;387		PTM0A_Start();
0B18	6344	call    _PTM0A_Start
0B19	0003	ret
				;388	}
				;389	
				;390	
				;391	void BuzzIsr(void)
				;392	{
				;393		if(AppData.buzzMs)
				_BuzzIsr:
				_BuzzIsr:
0B1A	4752	mov     a, AppData[27]
0B1B	40EC	mov     ra14, a
0B1C	50EC	sz      ra14
0B1D	6B1F	jmp     _LI5
0B1E	6B25	jmp     _L67
				;394		{
				;395			AppData.buzzMs--;	
				_LI5:
0B1F	55EC	dec     ra14
0B20	476C	mov     a, ra14
0B21	40D2	mov     AppData[27], a
				;396			if(AppData.buzzMs == 1)
0B22	576C	sdza    ra14
0B23	6B25	jmp     _L67
				;397			{
				;398				PTM0A_Stop();
0B24	6346	call    _PTM0A_Stop
				_L67:
0B25	0003	ret
				;399			}
				;400		}	
				;401	}
				;402	
				;403	
				;404	
				;file F:\SVNRepo\Project\BS82D20A_AOPU_5KEY\USER_PROGRAM\AppMain.c
				;1	
				;2	#include    "USER_PROGRAM.H" 
				;3	
				;4	
				;5	APPDATA AppData;
				;6	
				;7	
				;8	void AppMainInit(void)
				;9	{
				;10		AppData.state = APP_STATE_INIT;
				_AppMainInit:
				_AppMainInit:
0652	5F37	clr     AppData[0]
				;11		AppData.sysTick = 0;
0653	5F3D	clr     AppData[6]
0654	5F3E	clr     AppData[7]
				;12		AppData.isTest = 0;
0655	5F51	clr     AppData[26]
				;13		AppData.func = 0X00;
0656	5F4F	clr     AppData[24]
				;14		AppData.funcLightHeating = 0X00;
0657	5F50	clr     AppData[25]
				;15		AppData.sysRTC = 0;
0658	5F4D	clr     AppData[22]
				;16		
				;17		AppData.AirBlowWorkTime = 0;
0659	5F41	clr     AppData[10]
065A	5F42	clr     AppData[11]
				;18		AppData.AirChangeWorkTime = 0;	
065B	5F44	clr     AppData[13]
065C	5F45	clr     AppData[14]
				;19		AppData.AirHeatingWorkTime = 0;
065D	5F47	clr     AppData[16]
065E	5F48	clr     AppData[17]
				;20		AppData.LightHeatingWorkTime = 0;
065F	5F4B	clr     AppData[20]
0660	5F4C	clr     AppData[21]
				;21	
				;22	
				;23		AppData.AirBlowWorkDelay = 0;
0661	5F43	clr     AppData[12]
				;24		AppData.AirChangeWorkDelay = 0;
0662	5F46	clr     AppData[15]
				;25		AppData.AirHeatingBlowDelay = 0;
0663	5F49	clr     AppData[18]
				;26		AppData.AirHeatingUnBlowDelay = 0;
0664	5F4A	clr     AppData[19]
				;27		
				;28		
				;29		AppData.ptc_on = 0;
0665	7453	clr     AppData[28].0
				;30		AppData.ptc_on_t = 1;
0666	70D3	set     AppData[28].1
				;31		AppData.aChg_on = 0;
0667	7553	clr     AppData[28].2
				;32		AppData.aChg_on_t = 1;
0668	71D3	set     AppData[28].3
				;33		AppData.aBlw_on = 0;
0669	7653	clr     AppData[28].4
				;34		AppData.aBlw_on_t = 1;
066A	72D3	set     AppData[28].5
				;35		AppData.lHt_on = 0;
066B	7753	clr     AppData[28].6
				;36		AppData.lHt_on_t = 1;
066C	73D3	set     AppData[28].7
				;37	
				;38		LedInit();
066D	200B	call    _LedInit
				;39		KeyInit();
066E	200A	call    _KeyInit
				;40		TimerInit();
066F	6326	call    _TimerInit
				;41		PTM0AInit();
0670	6336	call    _PTM0AInit
				;42		
				;43		UartInitial();
0671	637A	call    _UartInitial
0672	0003	ret
				;44		
				;45	#if SELF_TEST_EN
				;46		selftest_int();
				;47	#endif
				;48		
				;49	//#define QDP9016A 	0X00
				;50	//#define QDP9016B 	0X01
				;51	//#define TKG_18A 	0X02
				;52	//#define TKG_18B 	0X03
				;53	//#define TKG_18C 	0X04
				;54	//#define TKG_18D 	0X05
				;55	#if UART_ENABLE			
				;56		DebugString("机型: ");
				;57		if(MODLE_TYPE == QDP9016A)
				;58		{
				;59			DebugString("QDP9016A ");
				;60		}
				;61		else if(MODLE_TYPE == QDP9016B)
				;62		{
				;63			DebugString("QDP9016B ");
				;64		}
				;65		else if(MODLE_TYPE == TKG_18A)
				;66		{
				;67			DebugString("TKG_18A ");
				;68		}
				;69		else if(MODLE_TYPE == TKG_18B)
				;70		{
				;71			DebugString("TKG_18B ");
				;72		}
				;73		else if(MODLE_TYPE == TKG_18C)
				;74		{
				;75			DebugString("TKG_18C ");
				;76		}
				;77		else if(MODLE_TYPE == TKG_18D)
				;78		{
				;79			DebugString("TKG_18D ");
				;80		}
				;81		DebugString("\r\n");
				;82		
				;83		DebugString(__DATE__);
				;84		DebugString("    ");
				;85		DebugString(__TIME__);
				;86		DebugString("\r\n");
				;87	#endif
				;88	}
				;89	
				;90	void PeripheralSetAirBlow(void)
				;91	{
				;92		LED_AIR_BLOW_ON();	
				_PeripheralSetAirBlow:
				_PeripheralSetAirBlow:
0673	31B9	set     PC3
				;93		if(AppData.AirBlowWorkDelay == 0)
0674	50C3	sz      AppData[12]
0675	2E77	jmp     _L3
				;94		{
				;95			JK_AIR_BLOW_ON();
0676	3141	set     PD2
				;96		}
				;97	//	LED_AIR_CHANGE_OFF();
				;98	//	JK_AIR_CHANGE_OFF();
				;99		
				;100	//	LED_AIR_HEATING_OFF();
				;101	//	JK_AIR_HEATING_OFF();
				;102		
				;103		LED_STANDBY_OFF();
				_L3:
0677	61C0	call    _LED_STANDBY_OFF
0678	0003	ret
				;104	}
				;105	
				;106	void PeripheralUnsetAirBlow(void)
				;107	{
				;108		LED_AIR_BLOW_OFF();
				_PeripheralUnsetAirBlow:
				_PeripheralUnsetAirBlow:
0679	35B9	clr     PC3
				;109		if(AppData.AirHeatingWorkTime == 0)
067A	4747	mov     a, AppData[16]
067B	4548	or      a, AppData[17]
067C	390A	snz     Z
067D	2E7F	jmp     _L5
				;110		{
				;111			JK_AIR_BLOW_OFF();
067E	3541	clr     PD2
				_L5:
067F	0003	ret
				;112		}
				;113	}
				;114	
				;115	void PeripheralSetAirHeating(void)
				;116	{
				;117		LED_AIR_HEATING_ON();
				_PeripheralSetAirHeating:
				_PeripheralSetAirHeating:
0680	30B9	set     PC1
				;118		JK_AIR_BLOW_ON();
0681	3141	set     PD2
				;119		if(AppData.AirHeatingBlowDelay == 0)
0682	50C9	sz      AppData[18]
0683	2E85	jmp     _L8
				;120		{
				;121			JK_AIR_HEATING_ON();
0684	33A0	set     PB7
				;122		}
				;123	//	LED_AIR_BLOW_OFF();
				;124	//	JK_AIR_BLOW_OFF();
				;125			
				;126	//	LED_AIR_CHANGE_OFF();	
				;127	//	JK_AIR_CHANGE_OFF();
				;128		
				;129		LED_STANDBY_OFF();		
				_L8:
0685	61C0	call    _LED_STANDBY_OFF
0686	0003	ret
				;130	}
				;131	
				;132	void PeripheralUnsetAirHeating(void)
				;133	{
				;134		LED_AIR_HEATING_OFF();
				_PeripheralUnsetAirHeating:
				_PeripheralUnsetAirHeating:
0687	34B9	clr     PC1
				;135		JK_AIR_HEATING_OFF();
0688	37A0	clr     PB7
0689	0003	ret
				;136	}
				;137	
				;138	
				;139	void PeripheralSetAirChange(void)
				;140	{
				;141	//	LED_AIR_HEATING_OFF();
				;142	//	JK_AIR_HEATING_OFF();
				;143		
				;144	//	LED_AIR_BLOW_OFF();
				;145	//	JK_AIR_BLOW_OFF();
				;146			
				;147		LED_AIR_CHANGE_ON();	
				_PeripheralSetAirChange:
				_PeripheralSetAirChange:
068A	3139	set     PC2
				;148		if(AppData.AirChangeWorkDelay == 0)
068B	50C6	sz      AppData[15]
068C	2E8E	jmp     _L11
				;149		{
				;150			JK_AIR_CHANGE_ON();
068D	31C1	set     PD3
				;151		}
				;152		LED_STANDBY_OFF();		
				_L11:
068E	61C0	call    _LED_STANDBY_OFF
068F	0003	ret
				;153	}
				;154	
				;155	void PeripheralUnsetAirChange(void)
				;156	{
				;157		LED_AIR_CHANGE_OFF();	
				_PeripheralUnsetAirChange:
				_PeripheralUnsetAirChange:
0690	3539	clr     PC2
				;158		JK_AIR_CHANGE_OFF();
0691	35C1	clr     PD3
0692	0003	ret
				;159	}
				;160	
				;161	void PeripheralSetLightHeating(void)
				;162	{
				;163		LED_LIGHT_HEATING_ON();
				_PeripheralSetLightHeating:
				_PeripheralSetLightHeating:
0693	3039	set     PC0
				;164		JK_LIGHT_HEATING_ON();
0694	3320	set     PB6
				;165		
				;166		LED_STANDBY_OFF();		
0695	61C0	call    _LED_STANDBY_OFF
0696	0003	ret
				;167	}
				;168	
				;169	void PeripheralUnsetLightHeating(void)
				;170	{
				;171		LED_LIGHT_HEATING_OFF();
				_PeripheralUnsetLightHeating:
				_PeripheralUnsetLightHeating:
0697	3439	clr     PC0
				;172		JK_LIGHT_HEATING_OFF();
0698	3720	clr     PB6
0699	0003	ret
				;173	}
				;174	
				;175	void PeripheralSet(void)
				;176	{
				;177		if(AppData.isTest) return;
				_PeripheralSet:
				_PeripheralSet:
069A	50D1	sz      AppData[26]
069B	2F36	jmp     _L15
				;178		if(AppData.state != APP_STATE_LOOP) return;
069C	4737	mov     a, AppData[0]
069D	0A03	sub     a, 3H
069E	390A	snz     Z
069F	2F36	jmp     _L15
				;179	
				;180		if(AppData.AirBlowWorkTime)
06A0	4741	mov     a, AppData[10]
06A1	40EF	mov     rf14, a
06A2	4742	mov     a, AppData[11]
06A3	40F0	mov     rg14, a
06A4	476F	mov     a, rf14
06A5	4570	or      a, rg14
06A6	3D0A	sz      Z
06A7	2EAA	jmp     _L19
				;181		{
				;182			AppData.aBlw_on = 1;
06A8	7253	set     AppData[28].4
06A9	2EAB	jmp     _L20
				;183		}
				;184		else
				;185		{
				;186			AppData.aBlw_on = 0;
				_L19:
06AA	7653	clr     AppData[28].4
				;187	#if SELF_TEST_EN
				;188			selftest_checkAirBlowoff();
				;189	#endif
				;190		}
				;191		
				;192		if(AppData.AirChangeWorkTime)
				_L20:
06AB	4744	mov     a, AppData[13]
06AC	40F1	mov     rd14, a
06AD	4745	mov     a, AppData[14]
06AE	40F2	mov     re14, a
06AF	4771	mov     a, rd14
06B0	4572	or      a, re14
06B1	3D0A	sz      Z
06B2	2EB5	jmp     _L21
				;193		{
				;194			AppData.aChg_on = 1;
06B3	7153	set     AppData[28].2
06B4	2EB6	jmp     _L22
				;195		}
				;196		else
				;197		{
				;198			AppData.aChg_on = 0;
				_L21:
06B5	7553	clr     AppData[28].2
				;199	#if SELF_TEST_EN
				;200			selftest_checkAirChangeoff();
				;201	#endif
				;202		}
				;203	#if 1
				;204		if(AppData.AirHeatingWorkTime)
				_L22:
06B6	4747	mov     a, AppData[16]
06B7	40EA	mov     rb14, a
06B8	4748	mov     a, AppData[17]
06B9	40EB	mov     rc14, a
06BA	476A	mov     a, rb14
06BB	456B	or      a, rc14
06BC	3D0A	sz      Z
06BD	2EC0	jmp     _L23
				;205		{
				;206			AppData.ptc_on = 1; 
06BE	7053	set     AppData[28].0
06BF	2EC1	jmp     _L24
				;207		}
				;208		else
				;209		{
				;210			AppData.ptc_on = 0; 
				_L23:
06C0	7453	clr     AppData[28].0
				;211		}
				;212	#else
				;213		if(AppData.AirHeatingWorkTime)
				;214		{	
				;215			//AppData.ptc_on = 1; 
				;216			//AppData.aBlw_on = 0;																								//风暖必须打开吹风
				;217			if(AppData.AirHeatingWorkTime <= (AIR_HEATING_TIME-AIR_HEATING_BLOW_DELAY)) //1s后才开启风暖
				;218			{
				;219				AppData.ptc_on = 1; 
				;220			}
				;221			if(AppData.AirHeatingWorkTime <= AIR_HEATING_UNBLOW_DELAY)									//剩余30s用来吹风
				;222			{
				;223				AppData.ptc_on = 0; 	
				;224			}
				;225			if(AppData.AirHeatingWorkTime == 1)
				;226			{
				;227				if(AppData.AirBlowWorkTime == 0)
				;228				{
				;229					AppData.aBlw_on = 0;	
				;230	#if UART_ENABLE			
				;231					printf_rtc_time(AppData.sysRTC);	
				;232					DebugString("[吹风 关闭] \r\n");
				;233	#endif
				;234				}
				;235			}
				;236		}
				;237		else
				;238		{
				;239			AppData.ptc_on = 0;	
				;240	#if SELF_TEST_EN
				;241			selftest_checkPTCoff();
				;242	#endif
				;243		}
				;244	#endif
				;245	
				;246		if(AppData.LightHeatingWorkTime)
				_L24:
06C1	474B	mov     a, AppData[20]
06C2	40F3	mov     _readKey_2, a
06C3	474C	mov     a, AppData[21]
06C4	40F4	mov     _readKey_2[1], a
06C5	4773	mov     a, _readKey_2
06C6	4574	or      a, _readKey_2[1]
06C7	3D0A	sz      Z
06C8	2ECB	jmp     _L25
				;247		{
				;248			AppData.lHt_on = 1;	
06C9	7353	set     AppData[28].6
06CA	2ECC	jmp     _L26
				;249		}
				;250		else
				;251		{
				;252			AppData.lHt_on = 0;	
				_L25:
06CB	7753	clr     AppData[28].6
				;253	#if SELF_TEST_EN
				;254			selftest_checkLightHeatingoff();
				;255	#endif
				;256		}
				;257	
				;258		
				;259		if((AppData.AirBlowWorkTime == 0)&&
				_L26:
06CC	476F	mov     a, rf14
06CD	4570	or      a, rg14
06CE	390A	snz     Z
06CF	2EDE	jmp     _L27
06D0	4771	mov     a, rd14
06D1	4572	or      a, re14
06D2	390A	snz     Z
06D3	2EDE	jmp     _L27
				;260				(AppData.AirChangeWorkTime == 0)&&
06D4	476A	mov     a, rb14
06D5	456B	or      a, rc14
06D6	390A	snz     Z
06D7	2EDE	jmp     _L27
				;261				(AppData.AirHeatingWorkTime == 0)&&
06D8	4773	mov     a, _readKey_2
06D9	4574	or      a, _readKey_2[1]
06DA	390A	snz     Z
06DB	2EDE	jmp     _L27
				;262				(AppData.LightHeatingWorkTime == 0))
				;263		{
				;264			LED_STANDBY_ON();
				_L29:
06DC	61BD	call    _LED_STANDBY_ON
06DD	2EE1	jmp     _L28
				;265		}
				;266		else
				;267		{
				;268			if(AppData.standbyPressCnt)
				_L27:
06DE	50CE	sz      AppData[23]
06DF	2EDC	jmp     _L29
				;269			{
				;270				LED_STANDBY_ON();
				;271			}
				;272			else
				;273			{
				;274				LED_STANDBY_OFF();
06E0	61C0	call    _LED_STANDBY_OFF
				;275			}
				;276		}
				;277		
				;278		if(AppData.ptc_on_t != AppData.ptc_on)
				_L28:
06E1	4753	mov     a, AppData[28]
06E2	0E01	and     a, 1H
06E3	40EC	mov     ra14, a
06E4	5F6A	clr     rb14
06E5	7CD3	sz      AppData[28].1
06E6	54EA	inc     rb14
06E7	476A	mov     a, rb14
06E8	426C	sub     a, ra14
06E9	3D0A	sz      Z
06EA	2EF5	jmp     _L30
				;279		{
				;280			AppData.ptc_on_t = AppData.ptc_on;
06EB	476C	mov     a, ra14
06EC	43EC	addm    a, ra14
06ED	74D3	clr     AppData[28].1
06EE	476C	mov     a, ra14
06EF	45D3	orm     a, AppData[28]
				;281			if(AppData.ptc_on)
06F0	7853	snz     AppData[28].0
06F1	2EF4	jmp     _L31
				;282			{
				;283				PeripheralSetAirHeating();	
06F2	2680	call    _PeripheralSetAirHeating
06F3	2EF5	jmp     _L30
				;284			}
				;285			else
				;286			{
				;287				PeripheralUnsetAirHeating();
				_L31:
06F4	2687	call    _PeripheralUnsetAirHeating
				;288			}
				;289		}
				;290		
				;291		if(AppData.aChg_on_t != AppData.aChg_on)
				_L30:
06F5	5F6C	clr     ra14
06F6	7D53	sz      AppData[28].2
06F7	54EC	inc     ra14
06F8	5F6A	clr     rb14
06F9	7DD3	sz      AppData[28].3
06FA	54EA	inc     rb14
06FB	476A	mov     a, rb14
06FC	426C	sub     a, ra14
06FD	3D0A	sz      Z
06FE	2F0B	jmp     _L32
				;292		{
				;293			AppData.aChg_on_t = AppData.aChg_on;
06FF	516C	swapa   ra14
0700	1985	rr      ACC
0701	0EF8	and     a, F8H
0702	40EC	mov     ra14, a
0703	75D3	clr     AppData[28].3
0704	476C	mov     a, ra14
0705	45D3	orm     a, AppData[28]
				;294			if(AppData.aChg_on)
0706	7953	snz     AppData[28].2
0707	2F0A	jmp     _L33
				;295			{
				;296				PeripheralSetAirChange();	
0708	268A	call    _PeripheralSetAirChange
0709	2F0B	jmp     _L32
				;297			}
				;298			else
				;299			{
				;300				PeripheralUnsetAirChange();
				_L33:
070A	2690	call    _PeripheralUnsetAirChange
				;301			}
				;302		}
				;303		
				;304		
				;305		if(AppData.aBlw_on_t != AppData.aBlw_on)
				_L32:
070B	5F6C	clr     ra14
070C	7E53	sz      AppData[28].4
070D	54EC	inc     ra14
070E	5F6A	clr     rb14
070F	7ED3	sz      AppData[28].5
0710	54EA	inc     rb14
0711	476A	mov     a, rb14
0712	426C	sub     a, ra14
0713	3D0A	sz      Z
0714	2F21	jmp     _L34
				;306		{
				;307			AppData.aBlw_on_t = AppData.aBlw_on;
0715	516C	swapa   ra14
0716	1885	rl      ACC
0717	0EE0	and     a, E0H
0718	40EC	mov     ra14, a
0719	76D3	clr     AppData[28].5
071A	476C	mov     a, ra14
071B	45D3	orm     a, AppData[28]
				;308			if(AppData.aBlw_on)
071C	7A53	snz     AppData[28].4
071D	2F20	jmp     _L35
				;309			{
				;310				PeripheralSetAirBlow();	
071E	2673	call    _PeripheralSetAirBlow
071F	2F21	jmp     _L34
				;311			}
				;312			else
				;313			{
				;314				PeripheralUnsetAirBlow();
				_L35:
0720	2679	call    _PeripheralUnsetAirBlow
				;315			}
				;316		}
				;317		
				;318		if(AppData.lHt_on_t != AppData.lHt_on)
				_L34:
0721	5F6C	clr     ra14
0722	7F53	sz      AppData[28].6
0723	54EC	inc     ra14
0724	5853	rla     AppData[28]
0725	0E01	and     a, 1H
0726	40EA	mov     rb14, a
0727	476A	mov     a, rb14
0728	426C	sub     a, ra14
0729	3D0A	sz      Z
072A	2F36	jmp     _L15
				;319		{
				;320			AppData.lHt_on_t = AppData.lHt_on;
072B	5BEC	rrc     ra14
072C	5F6C	clr     ra14
072D	5BEC	rrc     ra14
072E	77D3	clr     AppData[28].7
072F	476C	mov     a, ra14
0730	45D3	orm     a, AppData[28]
				;321			if(AppData.lHt_on)
0731	7B53	snz     AppData[28].6
0732	2F35	jmp     _L36
				;322			{
				;323				PeripheralSetLightHeating();	
0733	2693	call    _PeripheralSetLightHeating
0734	2F36	jmp     _L15
				;324			}
				;325			else
				;326			{
				;327				PeripheralUnsetLightHeating();
				_L36:
0735	2697	call    _PeripheralUnsetLightHeating
				_L15:
0736	0003	ret
				;328			}
				;329		}
				;330	}
				;331	
				;332	//#define FUNC_AIR_BLOW					BIT(0)
				;333	//#define FUNC_AIR_CHANGE				BIT(1)
				;334	//#define FUNC_AIR_HEATING			BIT(2)
				;335	//#define FUNC_LIGHT_HEATING		BIT(3)
				;336	//#define FUNC_LIGHT_UP					BIT(4)
				;337	//#define FUNC_DRY							BIT(5)
				;338	//#define FUNC_NET_JOIN					BIT(6)
				;339	void AppTimerRun(void)
				;340	{
				;341	#if 0
				;342		static u8 s_led = 0;
				;343		if(s_led)
				;344		{
				;345			LED_AIR_BLOW_ON();
				;346			s_led = 0;
				;347		}
				;348		else
				;349		{
				;350			LED_AIR_BLOW_OFF();
				;351			s_led = 1;
				;352		}
				;353		return ;
				;354	#endif
				;355		if(AppData.AirBlowWorkTime)
				_AppTimerRun:
				_AppTimerRun:
0737	4741	mov     a, AppData[10]
0738	40EA	mov     rb14, a
0739	4742	mov     a, AppData[11]
073A	40EB	mov     rc14, a
073B	476A	mov     a, rb14
073C	456B	or      a, rc14
073D	3D0A	sz      Z
073E	2F45	jmp     _L38
				;356		{
				;357			AppData.AirBlowWorkTime--;	
073F	0FFF	mov     a, FFH
0740	436A	add     a, rb14
0741	40C1	mov     AppData[10], a
0742	0FFF	mov     a, FFH
0743	536B	adc     a, rc14
0744	40C2	mov     AppData[11], a
				;358		}
				;359		if(AppData.AirChangeWorkTime)
				_L38:
0745	4744	mov     a, AppData[13]
0746	40EA	mov     rb14, a
0747	4745	mov     a, AppData[14]
0748	40EB	mov     rc14, a
0749	476A	mov     a, rb14
074A	456B	or      a, rc14
074B	3D0A	sz      Z
074C	2F53	jmp     _L39
				;360		{
				;361			AppData.AirChangeWorkTime--;	
074D	0FFF	mov     a, FFH
074E	436A	add     a, rb14
074F	40C4	mov     AppData[13], a
0750	0FFF	mov     a, FFH
0751	536B	adc     a, rc14
0752	40C5	mov     AppData[14], a
				;362		}
				;363		if(AppData.AirHeatingWorkTime)
				_L39:
0753	4747	mov     a, AppData[16]
0754	40EA	mov     rb14, a
0755	4748	mov     a, AppData[17]
0756	40EB	mov     rc14, a
0757	476A	mov     a, rb14
0758	456B	or      a, rc14
0759	3D0A	sz      Z
075A	2F69	jmp     _L41
				;364		{
				;365			if(--AppData.AirHeatingWorkTime == 0)
075B	0FFF	mov     a, FFH
075C	43EA	addm    a, rb14
075D	0FFF	mov     a, FFH
075E	53EB	adcm    a, rc14
075F	476A	mov     a, rb14
0760	40C7	mov     AppData[16], a
0761	476B	mov     a, rc14
0762	40C8	mov     AppData[17], a
0763	476A	mov     a, rb14
0764	456B	or      a, rc14
0765	390A	snz     Z
0766	2F69	jmp     _L41
				;366			{
				;367				AppData.AirHeatingUnBlowDelay = AIR_HEATING_UNBLOW_DELAY;
0767	0F1E	mov     a, 1EH
0768	40CA	mov     AppData[19], a
				;368			}
				;369		}
				;370		
				;371		if(AppData.LightHeatingWorkTime)
				_L41:
0769	474B	mov     a, AppData[20]
076A	40EA	mov     rb14, a
076B	474C	mov     a, AppData[21]
076C	40EB	mov     rc14, a
076D	476A	mov     a, rb14
076E	456B	or      a, rc14
076F	3D0A	sz      Z
0770	2F77	jmp     _L43
				;372		{
				;373			AppData.LightHeatingWorkTime--;
0771	0FFF	mov     a, FFH
0772	436A	add     a, rb14
0773	40CB	mov     AppData[20], a
0774	0FFF	mov     a, FFH
0775	536B	adc     a, rc14
0776	40CC	mov     AppData[21], a
				;374		}
				;375		
				;376		if(AppData.standbyPressCnt)
				_L43:
0777	474E	mov     a, AppData[23]
0778	40EC	mov     ra14, a
0779	50EC	sz      ra14
077A	2F7C	jmp     _LI1
077B	2F7E	jmp     _L44
				;377		{
				;378			AppData.standbyPressCnt--;	
				_LI1:
077C	556C	deca    ra14
077D	40CE	mov     AppData[23], a
				;379		}
				;380	
				;381		if(AppData.AirBlowWorkDelay)
				_L44:
077E	4743	mov     a, AppData[12]
077F	40EC	mov     ra14, a
0780	50EC	sz      ra14
0781	2F83	jmp     _LI2
0782	2F89	jmp     _L46
				;382		{
				;383			if(--AppData.AirBlowWorkDelay == 0)
				_LI2:
0783	55EC	dec     ra14
0784	476C	mov     a, ra14
0785	40C3	mov     AppData[12], a
0786	50EC	sz      ra14
0787	2F89	jmp     _L46
				;384			{
				;385				JK_AIR_BLOW_ON();
0788	3141	set     PD2
				;386			}
				;387		}
				;388		if(AppData.AirChangeWorkDelay)
				_L46:
0789	4746	mov     a, AppData[15]
078A	40EC	mov     ra14, a
078B	50EC	sz      ra14
078C	2F8E	jmp     _LI3
078D	2F94	jmp     _L49
				;389		{
				;390			if(--AppData.AirChangeWorkDelay == 0)
				_LI3:
078E	55EC	dec     ra14
078F	476C	mov     a, ra14
0790	40C6	mov     AppData[15], a
0791	50EC	sz      ra14
0792	2F94	jmp     _L49
				;391			{
				;392				JK_AIR_CHANGE_ON();
0793	31C1	set     PD3
				;393			}
				;394		}
				;395	
				;396		if(AppData.AirHeatingBlowDelay)
				_L49:
0794	4749	mov     a, AppData[18]
0795	40EC	mov     ra14, a
0796	50EC	sz      ra14
0797	2F99	jmp     _LI4
0798	2F9F	jmp     _L52
				;397		{
				;398			if(--AppData.AirHeatingBlowDelay == 0)
				_LI4:
0799	55EC	dec     ra14
079A	476C	mov     a, ra14
079B	40C9	mov     AppData[18], a
079C	50EC	sz      ra14
079D	2F9F	jmp     _L52
				;399			{
				;400				JK_AIR_HEATING_ON();
079E	33A0	set     PB7
				;401			}
				;402		}
				;403	
				;404		if(AppData.AirHeatingUnBlowDelay)
				_L52:
079F	474A	mov     a, AppData[19]
07A0	40EC	mov     ra14, a
07A1	50EC	sz      ra14
07A2	2FA4	jmp     _LI5
07A3	2FAA	jmp     _L37
				;405		{
				;406			if(--AppData.AirHeatingUnBlowDelay == 0)
				_LI5:
07A4	55EC	dec     ra14
07A5	476C	mov     a, ra14
07A6	40CA	mov     AppData[19], a
07A7	50EC	sz      ra14
07A8	2FAA	jmp     _L37
				;407			{
				;408				JK_AIR_BLOW_OFF();
07A9	3541	clr     PD2
				_L37:
07AA	0003	ret
				;409			}
				;410		}
				;411	}
				;412	
				;413	
				;414	void BuzzDeal(u16 key)
				;415	{
				;416		switch(key)
				_BuzzDeal:
				_BuzzDeal:
07AB	4777	mov     a, key[0]
07AC	0C01	xor     a, 1H
07AD	4578	or      a, key[1]
07AE	3D0A	sz      Z
07AF	2FC4	jmp     _L71
07B0	4777	mov     a, key[0]
07B1	0C02	xor     a, 2H
07B2	4578	or      a, key[1]
07B3	3D0A	sz      Z
07B4	2FC4	jmp     _L71
07B5	4777	mov     a, key[0]
07B6	0C04	xor     a, 4H
07B7	4578	or      a, key[1]
07B8	3D0A	sz      Z
07B9	2FC4	jmp     _L71
07BA	4777	mov     a, key[0]
07BB	0C08	xor     a, 8H
07BC	4578	or      a, key[1]
07BD	3D0A	sz      Z
07BE	2FC4	jmp     _L71
07BF	4777	mov     a, key[0]
07C0	0C10	xor     a, 10H
07C1	4578	or      a, key[1]
07C2	390A	snz     Z
07C3	2FC6	jmp     _L69
				;417		{
				;418			case PR_K0:
				;419			case PR_K1:
				;420			case PR_K2:
				;421			case PR_K3:
				;422			case PR_K4:
				;423				BuzzMs(15);
				_L71:
07C4	0F0F	mov     a, FH
07C5	6315	call    _BuzzMs
				_L69:
07C6	0003	ret
				;424				break;
				;425				
				;426			default:
				;427				break;		
				;428		}
				;429		
				;430	}
				;431	
				;432	void AppTask(void)
				;433	{
				;434		u16 key;
				;435		
				;436		switch(AppData.state)
				_AppTask:
				_AppTask:
07C7	4737	mov     a, AppData[0]
07C8	0A00	sub     a, 0H
07C9	3D0A	sz      Z
07CA	2FE8	jmp     _L74
07CB	0A01	sub     a, 1H
07CC	3D0A	sz      Z
07CD	2FF1	jmp     _L75
07CE	4737	mov     a, AppData[0]
07CF	0A02	sub     a, 2H
07D0	3D0A	sz      Z
07D1	6801	jmp     _L76
07D2	0A01	sub     a, 1H
07D3	3D0A	sz      Z
07D4	681B	jmp     _L77
07D5	4737	mov     a, AppData[0]
07D6	0A04	sub     a, 4H
07D7	3D0A	sz      Z
07D8	68DA	jmp     _L78
07D9	0A01	sub     a, 1H
07DA	3D0A	sz      Z
07DB	68E2	jmp     _L79
07DC	4737	mov     a, AppData[0]
07DD	0A06	sub     a, 6H
07DE	3D0A	sz      Z
07DF	68F2	jmp     _L80
07E0	0A01	sub     a, 1H
07E1	3D0A	sz      Z
07E2	6900	jmp     _L81
07E3	4737	mov     a, AppData[0]
07E4	0A08	sub     a, 8H
07E5	390A	snz     Z
07E6	6918	jmp     _L72
07E7	690F	jmp     _L134
				;437		{
				;438			case 	APP_STATE_INIT:
				;439	#if UART_ENABLE			
				;440				DebugString("APP_STATE_INIT \r\n");
				;441	#endif
				;442				AppData.state = APP_STATE_START;
				_L74:
07E8	0F01	mov     a, 1H
07E9	40B7	mov     AppData[0], a
				;443				LedAllOn();
07EA	61C3	call    _LedAllOn
				;444				APP_TIMER_Set(&AppData.gTimer);
07EB	0FBF	mov     a, BFH
07EC	40F6	mov     byte, a
07ED	0F00	mov     a, 0H
07EE	40F7	mov     buf, a
07EF	6359	call    _APP_TIMER_Set
07F0	6815	jmp     _L130
				;445				BuzzMs(50);
				;446				break;
				;447				
				;448			case 	APP_STATE_START:
				;449				//DebugString("APP_STATE_START \r\n");
				;450	#if UART_ENABLE			
				;451				if(K0_PRESS)
				;452				{
				;453					DebugString("0 ");
				;454				}
				;455				if(K1_PRESS)
				;456				{
				;457					DebugString("1 ");
				;458				}
				;459				if(K2_PRESS)
				;460				{
				;461					DebugString("2 ");
				;462				}
				;463				if(K3_PRESS)
				;464				{
				;465					DebugString("3 ");
				;466				}
				;467				if(K4_PRESS)
				;468				{
				;469					DebugString("4 ");
				;470				}
				;471	#endif
				;472				if(APP_TIMER_Expired(AppData.gTimer,20))	//上电亮2s后关闭
				_L75:
07F1	0F14	mov     a, 14H
07F2	40F8	mov     seconds, a
07F3	5F79	clr     seconds[1]
07F4	473F	mov     a, AppData[8]
07F5	40F6	mov     byte, a
07F6	4740	mov     a, AppData[9]
07F7	40F7	mov     buf, a
07F8	6348	call    _APP_TIMER_Expired
07F9	40DB	mov     ra, a
07FA	50DB	sz      ra
07FB	2FFD	jmp     _LI6
07FC	6918	jmp     _L72
				;473				{
				;474					AppData.state = APP_STATE_CHECK_KEY;	
				_LI6:
07FD	0F02	mov     a, 2H
07FE	40B7	mov     AppData[0], a
				;475					LedAllOff();
07FF	61CA	call    _LedAllOff
0800	68DC	jmp     _L131
				;476					APP_TIMER_Set(&AppData.gTimer);
				;477				}
				;478				break;
				;479				
				;480			case 	APP_STATE_CHECK_KEY:
				;481				if(K4_PRESS && K3_PRESS)
				_L76:
0801	793C	snz     AppData[5].2
0802	6818	jmp     _L84
0803	79BA	snz     AppData[3].3
0804	6818	jmp     _L84
				;482				{
				;483					if(APP_TIMER_Expired(AppData.gTimer,20))	//上电亮2s后关闭
0805	0F14	mov     a, 14H
0806	40F8	mov     seconds, a
0807	5F79	clr     seconds[1]
0808	473F	mov     a, AppData[8]
0809	40F6	mov     byte, a
080A	4740	mov     a, AppData[9]
080B	40F7	mov     buf, a
080C	6348	call    _APP_TIMER_Expired
080D	40DB	mov     ra, a
080E	50DB	sz      ra
080F	6811	jmp     _LI7
0810	6918	jmp     _L72
				;484					{
				;485						AppData.state = APP_STATE_SELF_TEST_START;
				_LI7:
0811	0F04	mov     a, 4H
0812	40B7	mov     AppData[0], a
				;486						AppData.isTest = 1;
0813	0F01	mov     a, 1H
0814	40D1	mov     AppData[26], a
				;487						BuzzMs(50);
				_L130:
0815	0F32	mov     a, 32H
0816	6315	call    _BuzzMs
0817	6918	jmp     _L72
				;488	#if UART_ENABLE			
				;489						DebugString("APP_STATE_SELF_TEST_START \r\n");
				;490	#endif
				;491					}
				;492				}
				;493				else
				;494				{
				;495					AppData.state = APP_STATE_LOOP;
				_L84:
0818	0F03	mov     a, 3H
0819	40B7	mov     AppData[0], a
081A	6918	jmp     _L72
				;496	#if UART_ENABLE			
				;497					DebugString("APP_STATE_LOOP \r\n");
				;498	#endif
				;499				}
				;500				break;	
				;501				
				;502			case 	APP_STATE_LOOP:
				;503				//if(AppData.sysRTCTemp != AppData.sysRTC)
				;504				{
				;505				//		AppData.sysRTCTemp = AppData.sysRTC;
				;506						//printf_dec_u16(AppData.sysRTC);
				;507						//DebugString("\n");
				;508				}
				;509				if(APP_TIMER_Expired(AppData.gTimer,30))
				_L77:
081B	0F1E	mov     a, 1EH
081C	40F8	mov     seconds, a
081D	5F79	clr     seconds[1]
081E	473F	mov     a, AppData[8]
081F	40F6	mov     byte, a
0820	4740	mov     a, AppData[9]
0821	40F7	mov     buf, a
0822	6348	call    _APP_TIMER_Expired
0823	40DB	mov     ra, a
0824	50DB	sz      ra
0825	6827	jmp     _LI8
0826	682C	jmp     _L86
				;510				{
				;511					APP_TIMER_Set(&AppData.gTimer);
				_LI8:
0827	0FBF	mov     a, BFH
0828	40F6	mov     byte, a
0829	0F00	mov     a, 0H
082A	40F7	mov     buf, a
082B	6359	call    _APP_TIMER_Set
				;512	//				UART_SendByte(AppData.func);
				;513	//				DebugString("PORT:");
				;514	//				printf_u8(AppData.func);
				;515	//				DebugString("\n");
				;516				}
				;517				key = GetKeyMsg();
				_L86:
082C	61B1	call    _GetKeyMsg
082D	475B	mov     a, ra
082E	40FD	mov     key[0], a
082F	475C	mov     a, rb
0830	40FE	mov     key[1], a
				;518				if(key != NO_KEY)
0831	475B	mov     a, ra
0832	465C	and     a, rb
0833	0B01	add     a, 1H
0834	3C0A	sz      C
0835	6918	jmp     _L72
				;519				{
				;520					//UART_SendByte(key>>8&0X00FF);
				;521					//UART_SendByte(key);
				;522					BuzzDeal(key);
0836	477D	mov     a, key[0]
0837	40F7	mov     buf, a
0838	477E	mov     a, key[1]
0839	40F8	mov     seconds, a
083A	27AB	call    _BuzzDeal
				;523					switch(key)
083B	477D	mov     a, key[0]
083C	0C01	xor     a, 1H
083D	457E	or      a, key[1]
083E	3D0A	sz      Z
083F	6891	jmp     _L87
0840	477D	mov     a, key[0]
0841	0C02	xor     a, 2H
0842	457E	or      a, key[1]
0843	3D0A	sz      Z
0844	68B3	jmp     _L88
0845	477D	mov     a, key[0]
0846	0C04	xor     a, 4H
0847	457E	or      a, key[1]
0848	3D0A	sz      Z
0849	68C0	jmp     _L89
084A	477D	mov     a, key[0]
084B	0C08	xor     a, 8H
084C	457E	or      a, key[1]
084D	3D0A	sz      Z
084E	6855	jmp     _L90
084F	477D	mov     a, key[0]
0850	0C10	xor     a, 10H
0851	457E	or      a, key[1]
0852	390A	snz     Z
0853	6918	jmp     _L72
0854	6870	jmp     _L135
				;524					{
				;525						case PR_K3:	//归
				;526							if(AppData.AirBlowWorkTime)
				_L90:
0855	4741	mov     a, AppData[10]
0856	4542	or      a, AppData[11]
0857	3D0A	sz      Z
0858	685D	jmp     _L92
				;527							{
				;528								AppData.AirBlowWorkTime = 0;
0859	5F41	clr     AppData[10]
085A	5F42	clr     AppData[11]
				;529								AppData.AirBlowWorkDelay = 0;
085B	5F43	clr     AppData[12]
085C	6918	jmp     _L72
				;530							}
				;531							else
				;532							{
				;533								AppData.standbyPressCnt = 0;
				_L92:
085D	5F4E	clr     AppData[23]
				;534								AppData.AirBlowWorkTime = AIR_BLOW_TIME;
085E	0F08	mov     a, 8H
085F	40C1	mov     AppData[10], a
0860	0F07	mov     a, 7H
0861	40C2	mov     AppData[11], a
				;535	
				;536								AppData.AirHeatingBlowDelay = 0;
0862	5F49	clr     AppData[18]
				;537								AppData.AirHeatingUnBlowDelay = 0;
0863	5F4A	clr     AppData[19]
				;538								AppData.AirHeatingWorkTime = 0;
0864	5F47	clr     AppData[16]
0865	5F48	clr     AppData[17]
				;539								if(AppData.AirChangeWorkTime)	//濡㈡寮锛抽㈡锛归寤舵2s
0866	4744	mov     a, AppData[13]
0867	4545	or      a, AppData[14]
0868	3D0A	sz      Z
0869	6918	jmp     _L72
				;540								{
				;541									AppData.AirChangeWorkTime = 0;
086A	5F44	clr     AppData[13]
086B	5F45	clr     AppData[14]
				;542									AppData.AirChangeWorkDelay = 0;
086C	5F46	clr     AppData[15]
				;543									AppData.AirBlowWorkDelay = AIR_BLOW_DELAY;
086D	0F02	mov     a, 2H
086E	40C3	mov     AppData[12], a
086F	6918	jmp     _L72
				;544								}
				;545	#if SELF_TEST_EN
				;546								SelfTestAirBlowOn();
				;547	#endif	
				;548							}
				;549							break;
				;550							
				;551						case PR_K4:	//㈡
				;552							if(AppData.AirChangeWorkTime)
				_L135:
0870	4744	mov     a, AppData[13]
0871	4545	or      a, AppData[14]
0872	390A	snz     Z
0873	68AF	jmp     _L132
				;553							{
				;554								AppData.AirChangeWorkTime = 0;
				;555								AppData.AirChangeWorkDelay = 0;
				;556							}
				;557							else
				;558							{
				;559								AppData.standbyPressCnt = 0;
0874	5F4E	clr     AppData[23]
				;560								AppData.AirChangeWorkTime = AIR_CHANGE_TIME;
0875	0F08	mov     a, 8H
0876	40C4	mov     AppData[13], a
0877	0F07	mov     a, 7H
0878	40C5	mov     AppData[14], a
				;561								if(AppData.AirBlowWorkTime)	//濡归寮锛抽归锛㈡寤舵2s
0879	4741	mov     a, AppData[10]
087A	4542	or      a, AppData[11]
087B	3D0A	sz      Z
087C	6882	jmp     _L94
				;562								{
				;563									AppData.AirBlowWorkTime = 0;
087D	5F41	clr     AppData[10]
087E	5F42	clr     AppData[11]
				;564									AppData.AirBlowWorkDelay = 0;
087F	5F43	clr     AppData[12]
				;565									AppData.AirChangeWorkDelay = AIR_CHANGE_DELAY;
0880	0F02	mov     a, 2H
0881	40C6	mov     AppData[15], a
				;566								}
				;567								if(AppData.AirHeatingWorkTime)
				_L94:
0882	4747	mov     a, AppData[16]
0883	4548	or      a, AppData[17]
0884	3D0A	sz      Z
0885	6918	jmp     _L72
				;568								{
				;569									if(AppData.AirHeatingBlowDelay)	//濡PTC杩娌″伐浣
0886	50C9	sz      AppData[18]
0887	6889	jmp     _LI9
0888	688A	jmp     _L95
				;570									{
				;571										AppData.AirHeatingBlowDelay = 0;
				_LI9:
0889	5F49	clr     AppData[18]
				;572									}
				;573									AppData.AirHeatingUnBlowDelay = 1;	//抽归
				_L95:
088A	0F01	mov     a, 1H
088B	40CA	mov     AppData[19], a
				;574									AppData.AirHeatingWorkTime = 0;//抽PTC
088C	5F47	clr     AppData[16]
088D	5F48	clr     AppData[17]
				;575									AppData.AirChangeWorkDelay = AIR_CHANGE_DELAY;
088E	0F02	mov     a, 2H
088F	40C6	mov     AppData[15], a
0890	6918	jmp     _L72
				;576								}
				;577	#if SELF_TEST_EN
				;578								SelfTestAirChangeOn();
				;579	#endif	
				;580							}
				;581							break;
				;582						
				;583						case PR_K2: //椋
				;584							if(AppData.AirHeatingWorkTime)		//濡椋寮
				_L87:
0891	4747	mov     a, AppData[16]
0892	4548	or      a, AppData[17]
0893	3D0A	sz      Z
0894	68A1	jmp     _L96
				;585							{
				;586								if(AppData.AirHeatingBlowDelay)	//濡PTC杩娌″伐浣
0895	50C9	sz      AppData[18]
0896	6898	jmp     _LI10
0897	689C	jmp     _L97
				;587								{
				;588									AppData.AirHeatingBlowDelay = 0;
				_LI10:
0898	5F49	clr     AppData[18]
				;589									
				;590									AppData.AirHeatingUnBlowDelay = 1;	//抽归
0899	0F01	mov     a, 1H
089A	40CA	mov     AppData[19], a
089B	689E	jmp     _L98
				;591								}
				;592								else	//PTC宸茬宸ヤ锛瑕寮归
				;593								{
				;594									AppData.AirHeatingUnBlowDelay = AIR_HEATING_UNBLOW_DELAY;  //寤舵跺抽归
				_L97:
089C	0F1E	mov     a, 1EH
089D	40CA	mov     AppData[19], a
				;595								}
				;596								AppData.AirHeatingWorkTime = 0;//抽椋
				_L98:
089E	5F47	clr     AppData[16]
089F	5F48	clr     AppData[17]
08A0	6918	jmp     _L72
				;597							}
				;598							else
				;599							{
				;600								AppData.standbyPressCnt = 0;
				_L96:
08A1	5F4E	clr     AppData[23]
				;601								AppData.AirHeatingWorkTime = AIR_HEATING_TIME;
08A2	0F18	mov     a, 18H
08A3	40C7	mov     AppData[16], a
08A4	0F15	mov     a, 15H
08A5	40C8	mov     AppData[17], a
				;602								if(AppData.AirBlowWorkTime == 0)
08A6	4741	mov     a, AppData[10]
08A7	4542	or      a, AppData[11]
08A8	390A	snz     Z
08A9	68AC	jmp     _L99
				;603								{
				;604									AppData.AirHeatingBlowDelay = AIR_HEATING_BLOW_DELAY; //PTC寤舵1s
08AA	0F02	mov     a, 2H
08AB	40C9	mov     AppData[18], a
				;605								}
				;606								
				;607								AppData.AirBlowWorkTime = 0;
				_L99:
08AC	5F41	clr     AppData[10]
08AD	5F42	clr     AppData[11]
				;608								AppData.AirBlowWorkDelay = 0;
08AE	5F43	clr     AppData[12]
				;609							
				;610								AppData.AirChangeWorkTime = 0;
				_L132:
08AF	5F44	clr     AppData[13]
08B0	5F45	clr     AppData[14]
				;611								AppData.AirChangeWorkDelay = 0;
08B1	5F46	clr     AppData[15]
08B2	6918	jmp     _L72
				;612							}
				;613	#if 0
				;614							if(AppData.AirHeatingWorkTime > AIR_HEATING_UNBLOW_DELAY)	//澶浜寮舵	抽
				;615							{
				;616								AppData.AirHeatingWorkTime = AIR_HEATING_UNBLOW_DELAY;
				;617								AppData.AirHeatingWorkDelay = 0;
				;618							}
				;619							else if(AppData.AirHeatingWorkTime > 2)										//澶浜抽骞朵椋杩圭舵锛寮
				;620							{
				;621								AppData.AirHeatingWorkTime = AIR_HEATING_TIME-AIR_HEATING_BLOW_DELAY;
				;622							}
				;623							else							//澶浜抽骞朵椋宸茬涓逛锛寮
				;624							{
				;625								AppData.AirHeatingWorkTime = AIR_HEATING_TIME;
				;626								AppData.AirHeatingWorkDelay = AIR_HEATING_BLOW_DELAY;
				;627	#if SELF_TEST_EN
				;628								printf_dec_u16(AppData.AirHeatingWorkTime);
				;629								DebugString("\r\n");
				;630								SelfTestPTCOn();
				;631	#endif
				;632							}
				;633	#endif
				;634							break;
				;635						
				;636						case PR_K1://
				;637							if(AppData.LightHeatingWorkTime)
				_L88:
08B3	474B	mov     a, AppData[20]
08B4	454C	or      a, AppData[21]
08B5	3D0A	sz      Z
08B6	68BA	jmp     _L100
				;638							{
				;639								AppData.LightHeatingWorkTime = 0;
08B7	5F4B	clr     AppData[20]
08B8	5F4C	clr     AppData[21]
08B9	6918	jmp     _L72
				;640							}
				;641							else
				;642							{
				;643								AppData.standbyPressCnt = 0;
				_L100:
08BA	5F4E	clr     AppData[23]
				;644								AppData.LightHeatingWorkTime = LIGHT_HEATING_TIME;
08BB	0F18	mov     a, 18H
08BC	40CB	mov     AppData[20], a
08BD	0F15	mov     a, 15H
08BE	40CC	mov     AppData[21], a
08BF	6918	jmp     _L72
				;645	#if SELF_TEST_EN
				;646								SelfTestLightHeatingOn();
				;647	#endif
				;648							}
				;649							break;
				;650							
				;651							
				;652						case PR_K0://寰
				;653							AppData.AirBlowWorkTime = 0;
				_L89:
08C0	5F41	clr     AppData[10]
08C1	5F42	clr     AppData[11]
				;654							AppData.AirBlowWorkDelay = 0;
08C2	5F43	clr     AppData[12]
				;655							AppData.AirChangeWorkTime = 0;
08C3	5F44	clr     AppData[13]
08C4	5F45	clr     AppData[14]
				;656							AppData.AirChangeWorkDelay = 0;
08C5	5F46	clr     AppData[15]
				;657							if(AppData.AirHeatingWorkTime)
08C6	4747	mov     a, AppData[16]
08C7	4548	or      a, AppData[17]
08C8	3D0A	sz      Z
08C9	68D3	jmp     _L101
				;658							{
				;659								if(AppData.AirHeatingBlowDelay)//濡PTC杩娌″伐浣
08CA	50C9	sz      AppData[18]
08CB	68CD	jmp     _LI11
08CC	68D1	jmp     _L102
				;660								{
				;661									AppData.AirHeatingBlowDelay = 0;
				_LI11:
08CD	5F49	clr     AppData[18]
				;662									AppData.AirHeatingUnBlowDelay = 1;	//抽归
08CE	0F01	mov     a, 1H
08CF	40CA	mov     AppData[19], a
08D0	68D3	jmp     _L101
				;663								}
				;664								else//PTC宸茬宸ヤ锛瑕寮归
				;665								{
				;666									AppData.AirHeatingUnBlowDelay = AIR_HEATING_UNBLOW_DELAY;//寤舵跺抽归
				_L102:
08D1	0F1E	mov     a, 1EH
08D2	40CA	mov     AppData[19], a
				;667								}
				;668							}
				;669							AppData.AirHeatingWorkTime = 0;
				_L101:
08D3	5F47	clr     AppData[16]
08D4	5F48	clr     AppData[17]
				;670							AppData.LightHeatingWorkTime = 0;
08D5	5F4B	clr     AppData[20]
08D6	5F4C	clr     AppData[21]
				;671							AppData.standbyPressCnt = 2;
08D7	0F02	mov     a, 2H
08D8	40CE	mov     AppData[23], a
				;672							break;
08D9	6918	jmp     _L72
				;673						default:
				;674							break;
				;675					}//////	
				;676				}
				;677				//DebugString("+");
				;678				//UART_SendByte(_ctm0dl);
				;679				break;		//APP_STATE_LOOPbreak
				;680				
				;681				
				;682			case APP_STATE_SELF_TEST_START:
				;683				AppData.state = APP_STATE_SELF_TEST_SHOW_MODLE;
				_L78:
08DA	0F05	mov     a, 5H
08DB	40B7	mov     AppData[0], a
				;684				APP_TIMER_Set(&AppData.gTimer);
				_L131:
08DC	0FBF	mov     a, BFH
08DD	40F6	mov     byte, a
08DE	0F00	mov     a, 0H
08DF	40F7	mov     buf, a
08E0	6359	call    _APP_TIMER_Set
				;685	#if UART_ENABLE			
				;686				DebugString("APP_STATE_SELF_TEST_SHOW_MODLE \r\n");
				;687	#endif		
				;688				break;
08E1	6918	jmp     _L72
				;689				
				;690			case APP_STATE_SELF_TEST_SHOW_MODLE:
				;691				LedShowModle();
				_L79:
08E2	61D1	call    _LedShowModle
				;692				if(APP_TIMER_Expired(AppData.gTimer,20))
08E3	0F14	mov     a, 14H
08E4	40F8	mov     seconds, a
08E5	5F79	clr     seconds[1]
08E6	473F	mov     a, AppData[8]
08E7	40F6	mov     byte, a
08E8	4740	mov     a, AppData[9]
08E9	40F7	mov     buf, a
08EA	6348	call    _APP_TIMER_Expired
08EB	40DB	mov     ra, a
08EC	50DB	sz      ra
08ED	68EF	jmp     _LI12
08EE	6918	jmp     _L72
				;693				{
				;694					AppData.state = APP_STATE_SELF_TEST_LED_CYCLE;
				_LI12:
08EF	0F06	mov     a, 6H
08F0	40B7	mov     AppData[0], a
08F1	68F9	jmp     _L133
				;695					APP_TIMER_Set(&AppData.gTimer);
				;696					LedAllOff();
				;697	#if UART_ENABLE			
				;698					DebugString("APP_STATE_SELF_TEST_LED_CYCLE \r\n");
				;699	#endif
				;700				}
				;701				break;
				;702				
				;703			case APP_STATE_SELF_TEST_LED_CYCLE:
				;704				if(LedShowCycle())
				_L80:
08F2	61D9	call    _LedShowCycle
08F3	40DB	mov     ra, a
08F4	50DB	sz      ra
08F5	68F7	jmp     _LI13
08F6	6918	jmp     _L72
				;705				{
				;706					AppData.state = APP_STATE_SELF_TEST_JK_CYCLE;
				_LI13:
08F7	0F07	mov     a, 7H
08F8	40B7	mov     AppData[0], a
				;707					APP_TIMER_Set(&AppData.gTimer);
				_L133:
08F9	0FBF	mov     a, BFH
08FA	40F6	mov     byte, a
08FB	0F00	mov     a, 0H
08FC	40F7	mov     buf, a
08FD	6359	call    _APP_TIMER_Set
				;708					LedAllOff();
08FE	61CA	call    _LedAllOff
08FF	6918	jmp     _L72
				;709	#if UART_ENABLE			
				;710					DebugString("APP_STATE_SELF_TEST_JK_CYCLE \r\n");
				;711	#endif
				;712				}
				;713				break;
				;714				
				;715			case APP_STATE_SELF_TEST_JK_CYCLE:
				;716				if(JKShowCycle())
				_L81:
0900	6234	call    _JKShowCycle
0901	40DB	mov     ra, a
0902	50DB	sz      ra
0903	6905	jmp     _LI14
0904	6918	jmp     _L72
				;717				{
				;718					AppData.state = APP_STATE_SELF_TEST_KEY_CYCLE;
				_LI14:
0905	0F08	mov     a, 8H
0906	40B7	mov     AppData[0], a
				;719					APP_TIMER_Set(&AppData.gTimer);
0907	0FBF	mov     a, BFH
0908	40F6	mov     byte, a
0909	0F00	mov     a, 0H
090A	40F7	mov     buf, a
090B	6359	call    _APP_TIMER_Set
				;720					LedAllOff();
090C	61CA	call    _LedAllOff
				;721					AppData.func = 0X00;
090D	5F4F	clr     AppData[24]
090E	6918	jmp     _L72
				;722	#if UART_ENABLE			
				;723					DebugString("APP_STATE_SELF_TEST_KEY_CYCLE \r\n");
				;724	#endif
				;725				}
				;726				break;
				;727				
				;728			case APP_STATE_SELF_TEST_KEY_CYCLE:
				;729				if(KeyShowCycle())
				_L134:
090F	628E	call    _KeyShowCycle
0910	40DB	mov     ra, a
0911	50DB	sz      ra
0912	6914	jmp     _LI15
0913	6918	jmp     _L72
				;730				{
				;731						AppData.state = APP_STATE_LOOP;
				_LI15:
0914	0F03	mov     a, 3H
0915	40B7	mov     AppData[0], a
				;732						AppData.func = 0X00;
0916	5F4F	clr     AppData[24]
				;733						AppData.isTest = 0;
0917	5F51	clr     AppData[26]
				_L72:
0918	0003	ret
				;734	#if UART_ENABLE			
				;735						DebugString("APP_STATE_LOOP \r\n");
				;736	#endif
				;737				}
				;738				//No manual within 10s then go to APP_STATE_LOOP
				;739				break;
				;740				
				;741			default:
				;742				break;
				;743		}
				;744	}
				;745	
				;file F:\SVNRepo\Project\BS82D20A_AOPU_5KEY\USER_PROGRAM\timer.c
				;1	
				;2	#include    "USER_PROGRAM.H" 
				;3	
				;4	
				;5	void TimerInit(void)
				;6	{
				;7	#if 0
				;8		/*
				;9		fSUB 32k
				;10		一个时钟周期0.03125ms
				;11		TIMER_RELOAD = 320,那么一个计时周期就是10ms
				;12		
				;13	Bit 6~4 CT0CK2~CT0CK0：选择CTM0 计数时钟位
				;14	000：fSYS/4
				;15	001：fSYS
				;16	010：fH/16
				;17	011：fH/64
				;18	100：fSUB
				;19	101：fSUB
				;20	110：CTCK0 上升沿时钟
				;21	111：CTCK0 下降沿时钟
				;22		*/
				;23		_tmpc = 0;
				;24		
				;25		_ctm0c0 = 0X40;	//0100 0000
				;26		
				;27		_ctm0c1 = 0XC0;	//1100 0000
				;28		
				;29		_ctm0al = (TIMER_RELOAD>>0)&0x00ff;
				;30		_ctm0ah = (TIMER_RELOAD>>8)&0x00ff;
				;31	
				;32		_ct0cclr = 1;
				;33		
				;34		_ctma0e = 1;
				;35		_emi = 1;
				;36		
				;37		_ct0dpx = 1;
				;38		
				;39		_ct0pau = 0;
				;40		_ct0on = 1;
				;41	#else
				;42		/*
				;43		Fh 8M
				;44		Fh/64 = 125k
				;45		一个时钟周期0.008ms
				;46		TIMER_RELOAD = 625,那么一个计时周期就是5ms
				;47		
				;48	Bit 6~4 CT0CK2~CT0CK0：选择CTM0 计数时钟位
				;49	000：fSYS/4
				;50	001：fSYS
				;51	010：fH/16
				;52	011：fH/64
				;53	100：fSUB
				;54	101：fSUB
				;55	110：CTCK0 上升沿时钟
				;56	111：CTCK0 下降沿时钟
				;57		*/
				;58		_tmpc = 0;
				_TimerInit:
				_TimerInit:
0B26	1F30	clr     TMPC
				;59		
				;60		_ctm0c0 = 0x30;	//0100 0000
0B27	0F30	mov     a, 30H
0B28	00E1	mov     CTM0C0, a
				;61		
				;62		_ctm0c1 = 0xc0;	//1100 0000
0B29	0FC0	mov     a, C0H
0B2A	00E2	mov     CTM0C1, a
				;63		
				;64		_ctm0al = (TIMER_RELOAD>>0)&0x00ff;
0B2B	0F71	mov     a, 71H
0B2C	00E5	mov     CTM0AL, a
				;65		_ctm0ah = (TIMER_RELOAD>>8)&0x00ff;
0B2D	0F02	mov     a, 2H
0B2E	00E6	mov     CTM0AH, a
				;66	
				;67		_ct0cclr = 1;
0B2F	3062	set     CT0CCLR
				;68		
				;69		_ctma0e = 1;
0B30	308F	set     CTMA0E
				;70		_emi = 1;
0B31	300E	set     EMI
				;71		
				;72		_ct0dpx = 1;
0B32	30E2	set     CT0DPX
				;73		
				;74		_ct0pau = 0;
0B33	37E1	clr     CT0PAU
				;75		_ct0on = 1;
0B34	31E1	set     CT0ON
0B35	0003	ret
				;76	#endif
				;77	}
				;78	
				;79	
				;80	void PTM0AInit(void)
				;81	{
				;82		/*
				;83		fSYS/4
				;84		一个时钟周期0.5us
				;85		TIMER_RELOAD = 1000,那么一个计时周期就是500us
				;86		
				;87	Bit 6~4 CT0CK2~CT0CK0：选择CTM0 计数时钟位
				;88	000：fSYS/4
				;89	001：fSYS
				;90	010：fH/16
				;91	011：fH/64
				;92	100：fSUB
				;93	101：fSUB
				;94	110：CTCK0 上升沿时钟
				;95	111：CTCK0 下降沿时钟
				;96		*/
				;97		_tmpc = BIT(3);
				_PTM0AInit:
				_PTM0AInit:
0B36	0F08	mov     a, 8H
0B37	00B0	mov     TMPC, a
				;98		
				;99		_ptm0c0 = 0X00;	//0000 0000
0B38	1F67	clr     PTM0C0
				;100		
				;101		_ptm0c1 = 0X30;	//0011 0000
0B39	0F30	mov     a, 30H
0B3A	00E8	mov     PTM0C1, a
				;102		
				;103		_ptm0al = (PTM0A_RELOAD>>0)&0x00ff;
0B3B	0FF4	mov     a, F4H
0B3C	00EB	mov     PTM0AL, a
				;104		_ptm0ah = (PTM0A_RELOAD>>8)&0x00ff;
0B3D	0F01	mov     a, 1H
0B3E	00EC	mov     PTM0AH, a
				;105	
				;106		_pt0cclr = 1;
0B3F	3068	set     PT0CCLR
				;107		_pt0pol = 1;
0B40	3168	set     PT0POL
				;108	//	_ptma0e = 1;
				;109	
				;110		_pt0pau = 0;
0B41	37E7	clr     PT0PAU
				;111		_pt0on = 0;
0B42	35E7	clr     PT0ON
0B43	0003	ret
				;112	}
				;113	
				;114	void PTM0A_Start(void)
				;115	{
				;116		_pt0on = 1;
				_PTM0A_Start:
				_PTM0A_Start:
0B44	31E7	set     PT0ON
0B45	0003	ret
				;117	}
				;118	
				;119	void PTM0A_Stop(void)
				;120	{
				;121		_pt0on = 0;
				_PTM0A_Stop:
				_PTM0A_Stop:
0B46	35E7	clr     PT0ON
0B47	0003	ret
				;122	}
				;123	
				;124	u8 APP_TIMER_Expired(u16 timer, u16 seconds)
				;125	{
				;126	    if((AppData.sysTick - timer) > (seconds))
				_APP_TIMER_Expired:
				_APP_TIMER_Expired:
0B48	473D	mov     a, AppData[6]
0B49	4276	sub     a, timer[0]
0B4A	40DD	mov     rd, a
0B4B	473E	mov     a, AppData[7]
0B4C	5277	sbc     a, timer[1]
0B4D	40DE	mov     re, a
0B4E	0F01	mov     a, 1H
0B4F	40DB	mov     ra, a
0B50	4778	mov     a, seconds[0]
0B51	425D	sub     a, rd
0B52	4779	mov     a, seconds[1]
0B53	525E	sbc     a, re
0B54	380A	snz     C
0B55	6B57	jmp     _L6
0B56	5F5B	clr     ra
				;127	    {
				;128	        return true;
				;129	    }
				;130	    else
				;131	    {
				;132	        return false;
				;133	    }
				;134	    return false;
				;135	}
				_L6:
0B57	475B	mov     a, ra
0B58	0003	ret
				;136	
				;137	void APP_TIMER_Set(u16 *timer)
				;138	{
				;139	    *timer = AppData.sysTick;
				_APP_TIMER_Set:
				_APP_TIMER_Set:
0B59	4776	mov     a, timer[0]
0B5A	0083	mov     MP1, a
0B5B	4777	mov     a, timer[1]
0B5C	0081	mov     MP0, a
0B5D	0701	mov     a, MP0
0B5E	0084	mov     BP, a
0B5F	473D	mov     a, AppData[6]
0B60	0082	mov     [02H], a
0B61	1483	inc     MP1
0B62	473E	mov     a, AppData[7]
0B63	0082	mov     [02H], a
0B64	0003	ret
				;140	}
				;141	
				;142	
				;file F:\SVNRepo\Project\BS82D20A_AOPU_5KEY\USER_PROGRAM\uart.c
				;1	
				;2	#include    "USER_PROGRAM.H" 
				;3	
				;4	#if (UART_ENABLE) 
				;5	
				;6	void UART_SendByte(u8 byte)
				;7	{
				;8		while(!_txif);
				;9		_txr_rxr = byte;
				;10	}
				;11	
				;12	
				;13	
				;14	/************************************************************
				;15	@
				;16	************************************************************/
				;17	void putchar(char c)
				;18	{
				;19	    if (c == '\n')
				;20	    {
				;21	        UART_SendByte(0x0d);
				;22	        UART_SendByte(0x0a);
				;23	    }
				;24	    else
				;25	    {
				;26	        UART_SendByte((u8)c);
				;27	    }
				;28	}
				;29	
				;30	/************************************************************
				;31	@
				;32	************************************************************/
				;33	void get_hex_data(u8 dat)
				;34	{
				;35	   u8 dat0;
				;36	   if(dat<0x0a)
				;37	   {
				;38	       dat0 = dat+'0';
				;39	   }
				;40	   else
				;41	   {
				;42	       dat0 = dat+'A'-10;
				;43	   }
				;44	   putchar(dat0);
				;45	}  
				;46	/************************************************************
				;47	@
				;48	************************************************************/
				;49	void printf_u8(u8 dat)
				;50	{
				;51	    putchar(' ');
				;52	    get_hex_data(dat >> 4);
				;53	    get_hex_data(dat & 0xf);
				;54	    putchar(' ');
				;55	}
				;56	
				;57	
				;58	/************************************************************
				;59	@
				;60	************************************************************/
				;61	void printf_dec_u8(u8 dat)
				;62	{
				;63		u8 bai,shi,ge;
				;64		
				;65		bai = dat/100 + '0';
				;66		shi = (dat%100)/10 + '0';
				;67		ge = dat%10 + '0';
				;68		
				;69		UART_SendByte(bai);
				;70		UART_SendByte(shi);
				;71		UART_SendByte(ge);
				;72	}
				;73	
				;74	/************************************************************
				;75	@
				;76	************************************************************/
				;77	void printf_dec_u16(u16 dat)
				;78	{
				;79	#if 0
				;80		u8 wan,qian,bai,shi,ge;
				;81		
				;82	//	static volatile u8 wan __attribute__((at(0x488)));
				;83	//	static volatile u8 qian __attribute__((at(0x489)));
				;84	//	static volatile u8 bai __attribute__((at(0x48a)));
				;85	//	static volatile u8 shi __attribute__((at(0x48b)));
				;86	//	static volatile u8 ge __attribute__((at(0x48c)));
				;87		
				;88		
				;89		wan = (dat/10000) + '0';
				;90		qian = (dat%10000)/1000 + '0';
				;91		bai = (dat%1000)/100 + '0';
				;92		shi = (dat%100)/10 + '0';
				;93		ge = dat%10 + '0';
				;94		
				;95		
				;96		UART_SendByte(wan);
				;97		UART_SendByte(qian);
				;98		UART_SendByte(bai);
				;99		UART_SendByte(shi);
				;100		UART_SendByte(ge);
				;101	#endif
				;102	}
				;103	
				;104	
				;105	/************************************************************
				;106	@
				;107	************************************************************/
				;108	void printf_rtc_time(u16 dat)
				;109	{
				;110	#if 0
				;111		static volatile u8 shi __attribute__((at(0x488)));
				;112		static volatile u8 ge __attribute__((at(0x489)));
				;113		static volatile u8 hour __attribute__((at(0x48a)));
				;114		static volatile u8 minute __attribute__((at(0x48b)));
				;115		static volatile u8 second __attribute__((at(0x48c)));
				;116	
				;117		//u8 shi,ge;
				;118		//u8 hour,minute,second;
				;119		
				;120		hour = dat/3600;
				;121		minute = (dat%3600)/60;
				;122		second = dat%60;
				;123		
				;124		shi = (hour%100)/10 + '0';
				;125		ge = hour%10 + '0';
				;126		
				;127		UART_SendByte(shi);
				;128		UART_SendByte(ge);
				;129		UART_SendByte(':');
				;130		
				;131		shi = (minute%100)/10 + '0';
				;132		ge = minute%10 + '0';
				;133		
				;134		UART_SendByte(shi);
				;135		UART_SendByte(ge);
				;136		UART_SendByte(':');
				;137		
				;138		shi = (second%100)/10 + '0';
				;139		ge = second%10 + '0';
				;140		
				;141		UART_SendByte(shi);
				;142		UART_SendByte(ge);
				;143		
				;144		UART_SendByte(' ');
				;145		UART_SendByte(' ');
				;146	#endif
				;147	}
				;148	
				;149	
				;150	void DebugString(char *buf)
				;151	{
				;152		while(*buf != '\0')
				;153		{
				;154				UART_SendByte((u8)(*buf));
				;155				buf++;
				;156		}	
				;157	}
				;158	
				;159	void UartInitial(void)
				;160	{
				;161		_ucr2 &=~BIT(5);
				;162		_brg = 25;	//baud 9600
				;163		//_brg = 1;	//baud 125000
				;164		
				;165		
				;166	  _uarten = 1;	//UART使能
				;167	  _txen = 1;	//TX使能
				;168	  
				;169	  DebugString("\r\n\r\n\r\nHOLTEK BS82D20 Uart initial done!!!\r\n");
				;170	}
				;171	
				;172	#else
				;173	
				;174	void UART_SendByte(u8 byte)
				;175	{
				_UART_SendByte:
				_UART_SendByte:
0B65	40F6	mov     byte[0], a
				;176		while(!_txif);
				L0B66:
0B66	3828	snz     TXIF
0B67	6B66	jmp     L0B66
				;177		_txr_rxr = byte;
0B68	4776	mov     a, byte[0]
0B69	00AC	mov     TXR_RXR, a
0B6A	0003	ret
				;178	}
				;179	
				;180	void DebugString(char *buf)
				;181	{
				;182		while(*buf != '\0')
				_DebugString:
				_DebugString:
0B6B	6B71	jmp     _L6
				_L6:
0B71	4777	mov     a, buf[0]
0B72	0083	mov     MP1, a
0B73	4778	mov     a, buf[1]
0B74	0081	mov     MP0, a
0B75	6386	call    L0B86
0B76	40DB	mov     ra, a
0B77	50DB	sz      ra
0B78	6B6C	jmp     _L7
0B79	0003	ret
				;183		{
				;184				UART_SendByte((u8)(*buf));
				_L7:
0B6C	475B	mov     a, ra
0B6D	6365	call    _UART_SendByte
				;185				buf++;
0B6E	54F7	inc     buf[0]
0B6F	3D0A	sz      Z
0B70	54F8	inc     buf[1]
				;186		}	
				;187	}
				;188	
				;189	void UartInitial(void)
				;190	{
				;191		_ucr2 &=~BIT(5);
				_UartInitial:
				_UartInitial:
0B7A	36AA	clr     BRGH
				;192		//_brg = 25;	//baud 9600
				;193		_brg = 1;	//baud 125000
0B7B	0F01	mov     a, 1H
0B7C	00AB	mov     BRG, a
				;194		
				;195		
				;196	  _uarten = 1;	//UART使能
0B7D	33A9	set     UARTEN
				;197	  _txen = 1;	//TX使能
0B7E	33AA	set     TXEN
				;198	  
				;199	  DebugString("\r\n\r\n\r\nHOLTEK BS82D20 Uart initial done!!!\r\n");
0B7F	0F34	mov     a, 34H
0B80	40F7	mov     buf, a
0B81	0F8B	mov     a, 8BH
0B82	40F8	mov     seconds, a
0B83	636B	call    _DebugString
0B84	0003	ret
0B85	1483	inc     MP1
				L0B86:
0B86	3F81	sz      MP0.7
0B87	6B8C	jmp     L0B8C
0B88	0701	mov     a, MP0
0B89	0084	mov     BP, a
0B8A	0702	mov     a, [02H]
0B8B	0003	ret
				L0B8C:
0B8C	1B01	rrca    MP0
0B8D	0E3F	and     a, 3FH
0B8E	0089	mov     TBHP, a
0B8F	1B03	rrca    MP1
0B90	0087	mov     TBLP, a
0B91	1D05	tabrd   ACC
0B92	3C0A	sz      C
0B93	0708	mov     a, TBLH
0B94	0003	ret
				L0D6E:
				org	0d6eh
0D6E	0000	nop
				L0E69:
				org	0e69h
0E69	0000	nop
				L0F64:
				org	0f64h
0F64	0000	nop
				;200	}
				;201	
				;202	#endif
				;203	
				;204	
				data .SECTION 'DATA'
				__intc0 DB DUP (?) ; __intc0
				__intc1 DB DUP (?) ; __intc1
				__pa DB DUP (?) ; __pa
				__pac DB DUP (?) ; __pac
				__papu DB DUP (?) ; __papu
				__pb DB DUP (?) ; __pb
				__pbc DB DUP (?) ; __pbc
				__pbpu DB DUP (?) ; __pbpu
				__usr DB DUP (?) ; __usr
				__ucr1 DB DUP (?) ; __ucr1
				__ucr2 DB DUP (?) ; __ucr2
				__brg DB DUP (?) ; __brg
				__txr_rxr DB DUP (?) ; __txr_rxr
				__tmpc DB DUP (?) ; __tmpc
				__pc DB DUP (?) ; __pc
				__pcc DB DUP (?) ; __pcc
				__pcpu DB DUP (?) ; __pcpu
				__pd DB DUP (?) ; __pd
				__pdc DB DUP (?) ; __pdc
				__pdpu DB DUP (?) ; __pdpu
				__ctm0c0 DB DUP (?) ; __ctm0c0
				__ctm0c1 DB DUP (?) ; __ctm0c1
				__ctm0al DB DUP (?) ; __ctm0al
				__ctm0ah DB DUP (?) ; __ctm0ah
				__ptm0c0 DB DUP (?) ; __ptm0c0
				__ptm0c1 DB DUP (?) ; __ptm0c1
				__ptm0al DB DUP (?) ; __ptm0al
				__ptm0ah DB DUP (?) ; __ptm0ah
				POR_ID DB DUP (?) ; POR_ID
				AppData DB DUP (?) ; AppData
				keyCounter DB 2 DUP (?) ; keyCounter
				keyValue DB 2 DUP (?) ; keyValue
				standby DB DUP (?) ; standby
				led_state DB DUP (?) ; led_state
				led_state DB DUP (?) ; led_state
				ra DB DUP (?)
				rb DB DUP (?)
				rd DB DUP (?)
				re DB DUP (?)
				r104 DB DUP (?)
				r204 DB DUP (?)
				r110 DB DUP (?)
				r210 DB DUP (?)
				r114 DB DUP (?)
				r214 DB DUP (?)
				r314 DB DUP (?)
				r414 DB DUP (?)
				r514 DB DUP (?)
				r614 DB DUP (?)
				r714 DB DUP (?)
				rb14 DB DUP (?)
				rc14 DB DUP (?)
				ra14 DB DUP (?)
				r118 DB DUP (?)
				r218 DB DUP (?)
				rf14 DB DUP (?)
				rg14 DB DUP (?)
				rd14 DB DUP (?)
				re14 DB DUP (?)
				_readKey_2 DB DUP (?)
				_Interrupt_CTM0A_2 DB DUP (?)
				byte DB DUP (?) ; byte
				buf DB DUP (?) ; buf
				seconds DB 2 DUP (?) ; seconds
				key DB 2 DUP (?) ; key
				key DB 2 DUP (?) ; key
				tickCnt DB DUP (?) ; tickCnt
				rtcCnt DB 2 DUP (?) ; rtcCnt
				misCnt DB DUP (?) ; misCnt
